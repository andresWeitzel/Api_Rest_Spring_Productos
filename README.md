 ![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/select/listadoProductos.jpg)

   <div align="right">
    <img width="28" height="30" src="src/main/resources/static/icons/backend/java/png/java.png" />
    <img width="22" height="24" src="src/main/resources/static/icons/devops/png/maven.png" />
    <img width="26" height="26" src="src/main/resources/static/icons/devops/png/git.png" />
    <img width="27" height="27" src="src/main/resources/static/icons/devops/png/postman.png" />
    <img width="25" height="25" src="src/main/resources/static/icons/backend/java/png/spring-boot.png" /> 
    <img width="25" height="25" src="src/main/resources/static/icons/backend/java/png/spring-security.png" /> 
    <img width="25" height="25" src="src/main/resources/static/icons/database/png/mysql.png" />  
  </div>  

# Api Rest about Generic Electronic Products

Creaci贸n de una API REST utilizando el Framework Spring Boot con el IDE Spring Tool Suite 4 junto con Maven, Mysql, JPA-Hibernate y otras Tecnolog铆as.

* [Playlist Prueba de Funcionalidad](https://www.youtube.com/playlist?list=PLCl11UFjHurCf-3L-d9kDVD-VhpkgxxuC)

</br>



### Tecnolog铆as Implementadas

| **Tecnolog铆as** | **Versi贸n** | **Finalidad** |               
| ------------- | ------------- | ------------- |
| Java |   12.0.2 | JDK |
| Spring Tool Suite 4 | 4.9.0  | IDE |
| Spring Boot |   2.5.4  | Framework |
| Spring Security | 5.6.1 | Servicios de Seguridad |
| JSON Web Token | 0.9.1 | Creaci贸n de tokens de acceso | 
| Maven |  4.0.0 | Gestor de Proyectos |
| JPA-Hibernate | 5.4.27 | Framework para el mapeo de objetos y persistenciua en la db |
| PostMan | 9.4.1 | Test de Apis |
| XAMPP | 3.2.2  | Paquete de Servidores |
| Mysql | 10.1.38 | Sistema de Gesti贸n de Bases de Datos |
| GNU bash / Terminal | 4.4.23  | Bash / Terminal para el manejo e implementaci贸n de Git integrado al IDE Eclipse |
| Git | 2.29.1  | Control de Versiones |


</br>

### Descarga y Documentacion de las Tecnolog铆as Implementadas

| **Tecnolog铆a**  | **Descarga** | **Documentaci贸n** |               
| ------------- | ------------- | ------------- |
| Java-JDK 12 | https://www.oracle.com/java/technologies/javase/jdk12-archive-downloads.html |  https://docs.oracle.com/en/ |
| Spring Tool Suite 4 |https://spring.io/tools | https://spring.io/guides |
| Spring Security | https://spring.io/projects/spring-security | https://spring.io/projects/spring-security | 
| JSON Web Security | https://jwt.io/introduction/ | https://jwt.io/introduction/
| XAMPP | https://www.apachefriends.org/download.html | https://community.apachefriends.org/f/ |
| Maven Repository | - | https://mvnrepository.com/ | 
| PostMan | https://www.postman.com/downloads/ | https://www.postman.com/product/what-is-postman/ |
| Git  | https://git-scm.com/downloads |  https://git-scm.com/docs |

</br>

### Patrones de Dise帽o Implementados

| **Patr贸n de Dise帽o** | **Finalidad** |               
| ------------- | ------------- |
| DAO | Uso de interfaces entre la aplicaci贸n y el almacenamiento de datos. |
| MVC | Separaci贸n y Representaci贸n de los Datos, Manejo de errores, Escalabilidad, etc  |

</br>

### Dependencias Implementadas

| **Dependencia Maven**  | **Versi贸n** | **Finalidad** |               
| ------------- | ------------- | ------------- |
| mysql-connector | 8.0.21 |  Conexi贸n e Implementaci贸n de Queries a la db con Mysql |
| Hibernate-Core | 5.4.27 | El Core de Hibernate |
| JPA-Hibernate | 2.1 | Persistencia de datos a la db |
| Spring-data-jpa | 2.6.1 | Api de JpaRepository para el manejo de m茅todos | 
| Spring-boot-starter-security | 2.6.2 | Api se Spring Security para la Seguridad de la Aplicaci贸n | 
| Spring Security | 5.6.1 | Servicios de Seguridad |
| Javax Annotation API | 1.3.2 | Api para la lectura de Annotation |
| javax.xml.bind | 2.3.1 |  Dependencia para convertir Objetos Java en Objetos XML |
| jackson-databind | 2.12.4 |  Dependencia para convertir Objetos Java en Objetos JSON |
| JSON Web Token | 0.9.1 | Creaci贸n de tokens de acceso | 


</br>

### Descarga de Dependencias

* Repositorio dependencia mysql : https://mvnrepository.com/artifact/mysql/mysql-connector-java/8.0.21
* Repositorio dependencia Javax Annotation API: https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api/1.3.2
* Repositorio dependencia Hibernate-Core: https://search.maven.org/artifact/org.hibernate/hibernate-core/5.4.27.Final/jar
* Repositorio dependencia JPA-Hibernate: https://mvnrepository.com/artifact/org.hibernate.javax.persistence/hibernate-jpa-2.1-api/1.0.2.Final
* Repositorio dependencia Spring data JpaRepository: https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa/2.6.1
* Repositorio Spring-boot-starter-security: https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-security/2.6.2
* Repositorio dependencia javax.xml.bind : https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api
* Repositorio dependencia jackson-databind :  https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind 
* Repositorio dependencia spring-security : https://mvnrepository.com/artifact/org.springframework.security/spring-security-core
* Repositorio dependencia json web tokens : https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt/0.9.1


</br>

###  Documentaci贸n Adicional

| **Documento** | **Descripci贸n** | **Enlace** |               
| ------------- | ------------- | ------------- |
| README-Docker.md | Gu铆a de Docker y contenedores | [Ver Documento](README-Docker.md) |
| README_Postman.md | Colecci贸n de Postman y endpoints | [Ver Documento](README_Postman.md) |
| README_PASSWORDS.md | ** Contrase帽as y Generaci贸n de Hashes BCrypt** | [Ver Documento](mysql/init/README_PASSWORDS.md) |

** Recomendaci贸n:** Para generar hashes BCrypt seguros, consulta [README_PASSWORDS.md](mysql/init/README_PASSWORDS.md) que incluye enlaces a generadores online.

###  Soluci贸n de Problemas Comunes

#### **Problema: "Bad credentials" despu茅s de actualizar hashes BCrypt**
Si despu茅s de actualizar los hashes BCrypt en el archivo SQL sigues recibiendo "Bad credentials", es probable que la base de datos no se haya actualizado correctamente.

**Soluci贸n:**
```bash
# Forzar recreaci贸n completa de la base de datos
docker-compose down -v
docker-compose up -d
```

**Explicaci贸n:** Docker mantiene los datos en vol煤menes persistentes. El comando `down -v` elimina estos vol煤menes, forzando la recreaci贸n completa de la base de datos con los nuevos datos del archivo SQL.

#### **Problema: Aplicaci贸n no inicia (puerto 8092)**
La aplicaci贸n est谩 configurada para correr en el puerto **8092**, no en 8080.

**Verificar:**
```bash
# Verificar si la aplicaci贸n est谩 corriendo
netstat -an | findstr :8092

# Verificar procesos Java
tasklist | findstr java
```

#### **Comandos Maven en Windows:**
```bash
# Usar mvnw.cmd en lugar de mvnw
.\mvnw.cmd spring-boot:run

# O compilar primero
.\mvnw.cmd clean compile
.\mvnw.cmd spring-boot:run
```

#### **Problema: Token JWT no aparece en el body de la respuesta**
**S铆ntomas:**
- Login exitoso (200 OK) pero body vac铆o `{}`
- No se ve el token en la respuesta

**Explicaci贸n:**
El token JWT se devuelve en el **header de respuesta** `Authorization: Token: [JWT]`, no en el body.

**Soluci贸n:**
```bash
# El token est谩 en el header, no en el body
# Buscar en: Authorization: Token: eyJhbGciOiJIUzUxMiJ9...
```

**Ejemplo de uso:**
```bash
# 1. Login
POST http://localhost:8092/login
Content-Type: application/json
Body: {"usuario": "admin", "contrasenia": "Admin2024!"}

# 2. Usar token en siguientes peticiones
GET http://localhost:8092/v1/productos
Authorization: Token: [JWT_TOKEN_DEL_HEADER]
```


</br>

### Visualizaci贸n de la Api Rest Completa

</br>

### Obtenci贸n de Token con JWT

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/obtencionToken.jpg)

</br> 


### Select de todos los Productos de la API con el M茅todo GET y el Token

  ![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/select/selectProductos.jpg)


</br> 


### Select de todos los Productos de la API con M茅todo Incorrecto

 ![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/select/selectProductosMetodoHttpIncorrecto.jpg)

</br> 



### Listado de los Productos de la API mediante M茅todo HTTP GET

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/select/listadoProductos.jpg)
* Los M茅todos GET de B煤squeda seg煤n campos (getBy..) no se anexan para simplificar documentaci贸n gr谩fica, los mismos fueron testeados, probados y se detallan en su secci贸n correspondiente

</br> 


### Listado de los Productos de la API por Paginaci贸n (P谩gina 0 obtenci贸n 2 Productos)

  ![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/selectPagination/page_0_2.jpg)


</br> 


### Listado de los Productos de la API por Paginaci贸n (P谩gina 0 obtenci贸n 3 Productos)

  ![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/selectPagination/page_0_3.jpg)

</br> 


### Listado de los Productos de la API por Paginaci贸n (P谩gina 0 obtenci贸n 4 Productos)

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/selectPagination/page_0_4.jpg)

</br> 



### Listado de los Productos de la API por Paginaci贸n (P谩gina 1 obtenci贸n 2 Productos)

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/selectPagination/page_1_2.jpg)

</br> 




### Listado de los Productos de la API por Paginaci贸n (P谩gina 1 obtenci贸n 4 Productos)

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/selectPagination/page_1_4.jpg)

</br> 



### Inserci贸n de Un Producto mediante M茅todo HTTP POST

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/insert/insertUnProducto/insertUnProducto.jpg)

</br> 


### Log Trabajo Realizado con JPA-HIBERNATE

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/insert/insertUnProducto/hibernateInsertUnProducto.jpg)

</br> 


### Lista de Productos con la Nueva Inserci贸n

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/insert/insertUnProducto/selectProductoInsertado.jpg)

</br> 


### Inserci贸n de Varios Productos

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/insert/insertVariosProductos/insertVariosProductos.jpg)

</br> 



### Lista de Productos con las Nuevas Inserciones

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/insert/insertVariosProductos/selectInsertVariosProductos.jpg)

</br> 



### Modificaci贸n de un Producto mediante M茅todo HTTP PUT

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/update/updateProductos.jpg)

</br> 



### Visualizaci贸n de la Lista de Productos con el Producto Modificado

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/update/selectUpdateProductos.jpg)

</br> 




### Eliminaci贸n de Un Producto Mediante M茅todo HTTP DELETE

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/delete/deleteProducto.jpg)

</br> 



### Eliminaci贸n de Un Producto Mediante Otro M茅todo HTTP 

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/delete/DeleteProductoConOtroMetodo.jpg)

</br> 



### Listado de Productos sin el Producto Eliminado

![Index app](https://github.com/andresWeitzel/Graphics/blob/master/Proyectos/ApiRestProductosSpringBoot/CRUD/delete/selectDeleteProducto.jpg)

</br> 







<hr>

## ` Documentaci贸n y Gu铆a del Proyecto `
#### (Esta Documentaci贸n que Desarroll茅 es para la Creaci贸n y Configuraci贸n del Proyecto desde Cero, Manejo y Dependencias de Maven, Spring Tool Suite, Spring Booot, Hibernate-JPA, Mysql, Servidor de Despliegue y otros usos. Recomiendo Leerla y Realizar todo paso a paso como se indica en la misma).

</br>

## Indice

#### Secci贸n 1) Creaci贸n del Proyecto y Configuraciones   
   
   - [Paso 1) Creaci贸n y Configuraciones de un Proyecto Spring Boot con Maven en Spring Tool Suite 4.](#paso-1-creaci贸n-de-un-proyecto-spring-boot-con-maven-en-spring-tool-suite-4-y-configuraciones-iniciales)
  
   - [Paso 2) Otras Configuraciones del Proyecto.](#paso-2-otras-configuraciones-del-proyecto)



#### Secci贸n 2) Configuraci贸n de las Dependencias y el SGDB Mysql
   
   - [Paso 3) Dependencias del Proyecto.](#paso-3-dependencias-del-proyecto)
   
   - [Paso 4) Configuraciones del SGDB Mysql.](#paso-4-configuraciones-del-sgdb-mysql) 
   
   

#### Secci贸n 3) Configuraci贸n del Archivo de Propiedades(application.properties)
   
   - [Paso 5) Archivo de Propiedades(application.properties)](#paso-5-archivo-de-propiedades-application.properties)



#### Secci贸n 4) Creaci贸n y Configuraci贸n de las Clases Entidades y Clases Modelos
  
   - [Paso 6) Creaci贸n y Configuraci贸n de la Clase-Entidad Producto](#paso-6-creaci贸n-y-configuraci贸n-de-la-clase-entidad-producto)
   
   - [Paso 7) Creaci贸n y Configuraci贸n de la Clase-Modelo Producto](#paso-7-creaci贸n-y-configuraci贸n-de-la-clase-modelo-producto)
  
  
  
  
#### Secci贸n 5) Creaci贸n y Configuraci贸n de las Interfaces Repositories y Convertidores de Clases  

   - [Paso 8) Creaci贸n y Configuraci贸n de la Interfaz-Repository Producto](#paso-8-creaci贸n-y-configuraci贸n-de-la-interfaz-repository-producto)

   - [Paso 9) Creaci贸n y Configuraci贸n de la Clase Converter](#paso-9-creaci贸n-y-configuraci贸n-de-la-clase-converter)




#### Secci贸n 6) Creaci贸n y Configuraci贸n de los Services y Controllers

   - [Paso 10) Creaci贸n y Configuraci贸n de la Clase Service](#paso-10-creaci贸n-y-configuraci贸n-de-la-clase-service)
   
   - [Paso 11) Creaci贸n y Configuraci贸n de la Clase Controller](#paso-11-creaci贸n-y-configuraci贸n-de-la-clase-controller) 

   - [Paso 12) Test de los M茅todos CRUD de la API sin JWT](#paso-12-test-de-los-metodos-crud-de-la-clase-productocontroller) 



#### Secci贸n 7) Creaci贸n, Configuraci贸n y Prueba de SpringSecurity, Json Web Tokens y la API de Productos

   - [Paso 13) Creaci贸n y Configuraci贸n de la Clase Usuario](#paso-13-creaci贸n-y-configuraci贸n-de-la-clase-usuario)

   - [Paso 14) Creaci贸n y Configuraci贸n de la Interfaz I_UsuarioRepository](#paso-14-creaci贸n-y-configuraci贸n-de-la-interfaz-i_usuarioRepository)

   - [Paso 15) Creaci贸n y Configuraci贸n del Servicio UsuarioService](#paso-15-creaci贸n-y-configuraci贸n-del-servicio-usuarioservice)

   - [Paso 16) Creaci贸n y Configuraci贸n de la Clase de Configuraci贸n UsuarioConfiguration](#paso-16-creaci贸n-y-configuraci贸n-de-la-clase-de-configuracion-usuarioconfiguration)

   - [Paso 17) Creaci贸n y Configuraci贸n de la Clase de Configuraci贸n JwtUtilConfiguration](#paso-17-creaci贸n-y-configuraci贸n-de-la-clase-de-configuracion-jwtutilconfiguration)

   - [Paso 18) Creaci贸n y Configuraci贸n de la Clase de Configuraci贸n JwtFilterConfiguration](#paso-18-creaci贸n-y-configuraci贸n-de-la-clase-de-configuracion-jwtfilterconfiguration)

   - [Paso 19) Creaci贸n y Configuraci贸n de la Clase de Configuraci贸n LoginFilterConfiguration](#paso-19-creaci贸n-y-configuraci贸n-de-la-clase-de-configuracion-loginfilterconfiguration)

   - [Paso 20) Creaci贸n y Configuraci贸n de la Clase de Configuraci贸n WebSecurity](#paso-20-creaci贸n-y-configuraci贸n-de-la-clase-de-configuracion-websecurity)

   - [Paso 21) Test de Spring Security y JWT](#paso-21-test-de-spring-security-y-jwt)
	
   - [Paso 22) Verificaci贸n de la API Productos con JWT](#paso-22-verificacion-de-la-api-productos-con-jwt)





#### Secci贸n 8) Anotaciones

- [ Anotaciones Usadas para JPA](#anotaciones-usadas-para-jpa)
 
- [ Anotaciones Usadas para Spring](#anotaciones-usadas-para-spring)



#### Secci贸n 9) Uso y Manejo de GIT

- [ Uso y Manejo de Git.](#uso-y-manejo-de-git)
 




</br>

## Secci贸n 1) Creaci贸n del Proyecto y Configuraciones

</br>


### Paso 1) Creaci贸n de un Proyecto Spring Boot con Maven en Spring Tool Suite 4 y Configuraciones Iniciales.
#### (Primeramente deber谩s configurar tu espacio de trabajo, en donde se alojar谩 la aplicaci贸n. Cada vez que muevas el Proyecto de Directorio, recomiendo crear o setear nuevamente el Espacio de Trabajo).


* Una vez abierto Spring Tool Suite 4
  	* --> Seleccionas la Pesta帽a `File` 
   	* --> New 
   	* --> Spring Starter Proyect (Si no aparece buscar en Other).

* Se abrir谩 una Interfaz Gr谩fica, por defecto dejar marcado lo siguiente con los siguientes valores por defecto
   	 * --> Service Url : https://start.spring.io
   	 * --> Use default location por defecto (es la ruta absoluta de tu workspace)
   	 * --> Type : Maven
	 * --> Java Version : 8
	 * --> Packaging : Jar
	 * --> Language : Java
	 * --> Artifact : Por Defecto como est谩 (cambia autom谩ticamente cuando escribimos el Name del Proyect)
	  * --> Version  : Por Defecto como est谩
	  * --> Working Sets Desmarcado.

* Configuramos lo restante
   * --> Name : Api_Rest_Spring_Productos (Nombre del proyecto, en mi caso este). Debe cambiarse aut. el Artifact
   * --> Group : com.api.productos (Nombre del grupo, en mi caso este).
   * --> Description: Creaci贸n de una Api Rest de Productos con Spring  (en mi caso).
   * --> Package : com.api.productos (Nombre del grupo, este en mi caso).
   * --> Next

* En la Nueva Interfaz Gr谩fica elegimos la versi贸n y dependencia
   * --> Spring Boot Versi贸n : 2.5.6 o una que no sea la 煤ltima
   * --> Seleccionamos la casilla Spring Web
   * --> Next
   * --> Te muestra unas informaciones
   * --> Next

* Seguidamente Finish.

* Esperar a que finalice Spring la creaci贸n del Proyecto


</br>



### Paso 2) Otras Configuraciones del Proyecto.
#### (Para este paso se anexan configuraciones que para el Proyecto son relevantes, capaz creando el Proyecto desde otro IDE se autoconfiguran dichas configuraciones).

</br>

#### 2.1) Actualizaci贸n de Java-1.7 a 1.8 (Si seleccionaste una versi贸n Moderna de Spring no es Necesario esto)

* Vamos al `pom.xml` (el archivo al final de todo)

* Dentro de el tag `properties` donde dice java.versi贸n cambiar la version del compiler a 1.8, ctrl+s para guardar

* Click Derecho sobre el Proyecto
	* --> Maven
	* --> Update Proyect
	* --> Fijate que el Proyecto este seleccionado y Boton ok

* Si cambio JavaSE-1.7 a JavaSE-1.8 se efectuo el cambio

</br>

#### 2.2) Paquetes Maven `(Java Resources)`. (Si seleccionaste una versi贸n Moderna de Spring no es Necesario esto)

* Por Defecto Viene deshabilitada la opci贸n de paquetes Maven, en donde vamos a guardar nuestros paquetes y clases
	* --> Para habilitar las mismas, click Der sobre el Proyecto.
	* --> Properties.
	* --> Buscamos la secci贸n `Java Build Path`
	* --> Seleccionamos la casilla `Maven Dependencies`.
	* --> Apply and Close.
	* --> F5 y deber铆an aparecer `src/main/java` y `src/test/java`







</br>

## Secci贸n 2) Configuraci贸n de las Dependencias y el SGDB Mysql

</br>





### Paso 3) Dependencias del Proyecto
#### (Las siguientes dependencias del Proyecto se deber谩n agregar al pom.xml para el correcto funcionamiento del Proyecto).
#### (EN LOS SIGUIENTES PASOS SE AGREGAN LAS DEPENDENCIAS DE FORMA MANUAL, ES IMPORTANTE SABER QUE LA OTRA FORMA DE INCLUIR LAS MISMAS ES A TRAVS DE SPRING AL MOMENTO DE CREAR EL PROYECTO, EN MI CASO OPT POR ESTA)

#### 3.1) Dependencia para el conector de Mysql.
* Buscamos la dependencia Mysql Connector (https://mvnrepository.com/artifact/mysql/mysql-connector-java/8.0.21)
* Copias la Dependencia desde Maven o desde ac谩 y la incluis en el `pom.xml`

```xml
<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.21</version>
</dependency>

```

</br>

#### 3.2) Dependencia para `JPA-HIBERNATE `
#### (Persistenca de Datos en la db, de esto se encarga Spring).

* La Primera ser谩 el core de Hibernate, hibernate-core la 5.4... Final (https://search.maven.org/artifact/org.hibernate/hibernate-core/5.4.27.Final/jar).

```xml
<dependency>
  <groupId>org.hibernate</groupId>
  <artifactId>hibernate-core</artifactId>
  <version>5.4.27.Final</version>
</dependency>
```
* ...

* La segunda ser谩 JPA para Hibernate, la m谩s importante, ya que nos desacoplamos de depender de Hibernate en un futuro, y nos centramos en trabajar con JPA, la dependencia es JPA-Hibernate 2.1 (https://mvnrepository.com/artifact/org.hibernate.javax.persistence/hibernate-jpa-2.1-api/1.0.2.Final).

```xml
<!-- https://mvnrepository.com/artifact/org.hibernate.javax.persistence/hibernate-jpa-2.1-api -->
<dependency>
    <groupId>org.hibernate.javax.persistence</groupId>
    <artifactId>hibernate-jpa-2.1-api</artifactId>
    <version>1.0.2.Final</version>
</dependency>

```
* ...
 
* La Tercera dependencia ser谩 para las Lecturas de las Anotaciones para JPA-Hibernate, Javax Annotation API (https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api/1.3.2)

```xml
<!-- https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api -->
<dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.3.2</version>
</dependency>
```


</br>


#### 3.3) Dependencia para convertir Objetos Java en Objetos XML.

* Buscamos javax.xml.bin, la versi贸n 2.3.1, (https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api/2.3.1)
* Copias la Dependencia desde Maven o desde ac谩 y la incluis en el pom.xml

```xml
<!-- https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api -->
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.1</version>
</dependency>

```

</br>

#### 3.4) Dependencia para el Uso de los m茅todos de `JpaRepository`
#### (Usaremos la api de Spring Data Jpa ya que nos va a ahorrar desarrollar los m茅todos que realicen las consultas sql a la db, creando menos cantidad de c贸digo ).

* Buscamos la dependencia (https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa/2.6.1)
* C贸digo de la Dependencia
```xml
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
    <version>2.6.1</version>
</dependency>

```


</br>

#### 3.5) Dependencia para convertir Objetos Java en Objetos JSON.

* Buscamos jackson databind, la versi贸n 2.12.4, (https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind/2.12.4)
* Copias la dependencia desde Maven o de ac谩, luego lo inclu铆s en el pom.xml

```xml
<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.12.4</version>
</dependency>

```

</br>

#### 3.6) Dependencia para la Seguridad de la aplicaci贸n con Spring Security.

* Como siempre ,en MavenRepository, buscamos Spring Security Core, versi贸n 5.6.1 (https://mvnrepository.com/artifact/org.springframework.security/spring-security-core/5.6.1)
* Copias la dependencia desde Maven o desde ac谩, luego lo incluis en el pom.xml

```xml
<!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-core -->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-core</artifactId>
    <version>5.6.1</version>
</dependency>


```

</br>

* La segunda dependencia ser谩 para la API de Spring Security, Spring boot starter security 2.6.2 (https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-security/2.6.2)
* Incluis la dependeencia dentro del pom.xml

```xml
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-security -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
    <version>2.6.2</version>
</dependency>


```

</br>

#### 3.7) Dependencia para los tokens de la aplicaci贸n y autenticaci贸n con JSON .

* Buscamos JJWT, versi贸n 0.9.1 (https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt/0.9.1)
* Copias la dependencia desde Maven o desde ac谩, luego lo incluis en el pom.xml

```xml

<!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>



```

* ...
* Ctrl + s Guardas 
* Click Der sobre el proyecto
* Maven y update Maven o Alt + F5
* Fijarse dentro de Maven Dependencies si Maven descargo las mismas
 




</br>

### Paso 4) Configuraciones del SGDB Mysql.
#### (El Sistema de Gesti贸n de Base de datos(SGDB) es un conjunto de programas que nos permiten gestionar la base de datos, es com煤n confundirse con el Nombre, Mysql como tal no es la Base de Datos, sino un SGDB, el Motor de Mysql que he implementado es INNODB, el m谩s com煤n).

* Hasta ac谩 deber铆as tener incluido el `conector` para Mysql en el `pom` para que se descargue la dependencia (Fijarse la Secci贸n de dependencias).

* Abrimos la Herramienta `XAMPP` ( Buscate un microtutorial para usarla ), o la que se tenga, levantamos los Servicios de Mysql y Creamos una Nueva Base de Datos.
	* --> Depende que S.O tengas podr谩s o no tener esta herramienta, no hace falta tenerla, tambi茅n es posible levantar un servicio mysql desde la bash en Linux
	* --> Una vez abierto, en el control panel inicializas los servicios de Mysql y Apache para ver las dbs desde el localhost en el Navegador
	* --> Colocas localhost... en el navegador y accedes a `PHPMYADMIN` o clickeas Admin desde xampp en la parte de Apache.
	* --> Vamos a crear una db, para eso en la esquina izquierda superior toc谩s en Nueva.
	* --> Colocas el Nombre a la derecha (en mi caso `db_api_productos`), dejas latin1 y luego en Crear
	* --> Vamos a Crear una sola tabla con solo 4 campos para persistir posteriormente los datos con Hibernate.
	* --> Selecciona la db creada y a la derecha te va a aparecer crear tabla, colocamos en Nombre productos, numero de columnas 4 y continuar.
	* --> Ahora creamos los campos(columnas), el primero sera id, tipo int y al final en Indice colocas primary(llave primaria).
	* --> El segundo campo ser谩 el c贸digo del Producto, colocamos codigo, tipo varchar, longitud 30.
	* --> El Tercero ser谩 nombre, colocamos nombre, varchar, 30
	* --> El 煤limo ser谩 el precio, colocamos precio, float, 30
	* --> Guardar.
	* --> Si desplegamos la db, se te deberia desplegar la nueva tabla y si la seleccionas los nuevos campos creados.
	* --> Solamente creamos la db, la tabla y los 4 campos, la config de usuarios, atributos de los campos , etc, lo dejamos todo por defecto para realizar la conexion con el connector de mysql posteriormente.
	* --> Fijate de Visualizar la db creada, la tabla y los campos, continuamos..







</br>


## Secci贸n 3) Configuraci贸n del Archivo de Propiedades `(application.properties)`


</br>




### Paso 5) Archivo de Propiedades `(application.properties)`
#### (El uso de Spring Boot properties es muy habitual cuando trabajamos con una aplicaci贸n de Spring Boot. A diferencia de otras aplicaciones cl谩sicas de Spring Framework , Spring Boot hace uso del principio de convenci贸n sobre configuraci贸n y define un fichero por defecto de propiedades . Este fichero se encuentra en la carpeta resources (src/main/resources/application.properties) de nuestro proyecto.)

</br>

#### 5.1) Configuraciones del Server de Spring 
* Vamos a configurar el Puerto del Server y los errores HTTP
* Nos posicionamos sobre el Archivo application.properties (src/main/resources/application.properties) y copias-pegas lo siguiente

```xml
server.port = 8092
server.error.whitelabel.enabled=true
```

#### 5.2) Configuraciones de la Conexi贸n a la Base de Datos
* Primeramente deber铆as haber creado la db paso a paso explicado en la secci贸n anterior.
* Configuramos la url, el usuario y contrase帽a
* El nombre de la URL cambia si creaste otra db. Luego del localhost tendr谩s que escribir el nombre completo de la db creada
* Lo mismo para el Usuario y Contrase帽a, por defecto siempre el user root y contrase帽a vac铆o (Pruebas Locales, no Producci贸n).

```xml
spring.datasource.url = jdbc:mysql://localhost:3306/db_api_productos?serverTimezone=UTC
spring.datasource.username = root
spring.datasource.password = 
```

#### 5.3) Configuraciones de JPA-Hibernate
* No es requerimiento saber hibernate pero si lo recomiendo para entender como se produce la persistencia de los datos en la db, la simplificaci贸n de tiempo y codificaci贸n que demanda jdbc puro en relaci贸n a este Framework, etc.
* Vamos a declarar las siguientes propiedades.
* jpa.show-sql es para que se muestren las sentencias por consola
* jpa.hibernate.ddl-auto es para la la actualizaci贸n o creaci贸n de la db en cada actualizaci贸n del proyecto. Si lo declaramos update actualiza la db o create  la crea con todas sus tablas y campos.
* jpa.hibernate.naming.strategy es la estrategia de nomenclatura que usa Hibernate
* jpa.properties.hibernate.dialect es la asignaci贸n del tipo de Base de Datos que vamos a utilizar 

```xml
spring.jpa.show-sql = true
spring.jpa.hibernate.ddl-auto = update
spring.jpa.hibernate.naming.strategy = org.hibernate.cfg.ImprovedNamingStrategy
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect
```

* C贸digo Completo del application.properties


```xml
server.port = 8092
server.error.whitelabel.enabled=true

spring.datasource.url = jdbc:mysql://localhost:3306/db_api_productos?serverTimezone=UTC
spring.datasource.username = root
spring.datasource.password = 


spring.jpa.show-sql = true
spring.jpa.hibernate.ddl-auto = update
spring.jpa.hibernate.naming.strategy = org.hibernate.cfg.ImprovedNamingStrategy
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect

```

* ...
   * --> Ctrl + s Guardas 
   * --> Click Der sobre el proyecto
   * --> Maven y update Maven o Alt + F5
   * --> Fijarse dentro de Maven Dependencies si Maven descargo la misma





</br>

## Secci贸n 4) Creaci贸n y Configuraci贸n de las Clases Entidades y Clases Modelos

</br>





### Paso 6) Creaci贸n y Configuraci贸n de la Clase-Entidad Producto
#### ( Existen 2 Conceptualizaciones en este caso. La primera es que a una Clase se le llame Entidad-Modelo y la otra que exista la misma Clase definida como Modelo y Entidad (osea 2 clases casi identicas). Varios prefieren usar la primera o la segunda dependiendo c煤al sea la finalidad (ahorrar tiempo de c贸digo, modularizar el c贸digo o lo que sea). Yo opt茅 por la segunda ya que si bien es verdad que se tiene que generar m谩s c贸digo, cuando el mismo crezca los problemas van a tener un alcance m谩s controlado).
#### ( Las Entidades se trabajan en los Repositorios y los Modelos en los Controladores o Service )

</br>

#### 6.1) Creaci贸n de la Clase `ProductoEntidad`

* Creamos un paquete llamado mypackages.entities dentro de com.api.productos (src/main/java/com.api.productos). Es importante que este dentro del mismo ya que sino Spring no desplegar谩 la app de forma correcta.
	* --> Click Der sobre la ruta mencionada  
	* --> New --> Package
	* --> En Name seguido de com.api.productos colocamos mypackages.entities (com.api.productos.mypackages.entities)
	* --> Finish

* Creamos la Clase-Entidad Producto
 	* --> Click Der sobre el paquete creado
 	* --> New --> Class
 	* --> Siempre asegurarse la ruta de creaci贸n a trav茅s del Source Folder y Package
 	* --> En Name colocamos Producto
 	* --> Finish

```java

package com.api.productos.mypackages.entities;

public class Producto {

}
 
```

</br>

#### 6.1) Configuraci贸n de la Clase  `ProductoEntidad`

* Primeramente vamos a implementar la Clase Serializable dentro de la Clase Producto Creada, el proceso de serializaci贸n es la conversi贸n de los objetos java en flujos de bytes(c贸digo binario para la correcta transferencia de datos).

```java


package com.api.productos.mypackages.entities;

import java.io.Serializable;

public class Producto implments Serializable{

}

```


* Creamos los atributos o campos de la Clase que a su vez ser谩n los campos de la db, es importante destacar que se deber谩n mantener la compatibilidad de tipos de datos entre java y mysql haciendo referencia a los tipos seg煤n cada lenguaje

```java

package com.api.productos.mypackages.entities;

import java.io.Serializable;

public class Producto implements Serializable{

	
	private int id;
	
	private String codigo;
	
	private String nombre;
	
	private float precio;
	
}

 
```

* Creamos los getters, setters, toString y contructores(sin/con parametros)


```java

package com.api.productos.mypackages.entities;

import java.io.Serializable;

public class Producto implements Serializable{
	

	private int id;

	private String codigo;
	
	private String nombre;
	
	private float precio;
	
	
	public Producto() {
	}
	

	public Producto(String codigo, String nombre, String precio) {
		super();
		this.codigo = codigo;
		this.nombre = nombre;
		this.precio = precio;
	}
	

	public Producto(int id, String codigo, String nombre, String precio) {
		super();
		this.id = id;
		this.codigo = codigo;
		this.nombre = nombre;
		this.precio = precio;
	}





	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getCodigo() {
		return codigo;
	}

	public void setCodigo(String codigo) {
		this.codigo = codigo;
	}

	public String getNombre() {
		return nombre;
	}

	public void setNombre(String nombre) {
		this.nombre = nombre;
	}

	public float getPrecio() {
		return precio;
	}

	public void setPrecio(float precio) {
		this.precio = precio;
	}
	
	
	

	@Override
	public String toString() {
		return "Producto [id=" + id + ", codigo=" + codigo + ", nombre=" + nombre + ", precio=" + precio + "]";
	}
	

}


```

* Vamos a hacer uso de las Anotaciones para que Spring use JPA-Hibernate para mapear y persistir los datos en la db.
* Con la anotaci贸n `@Table(name="nombreDeLaClaseOpcional")` le indicamos que la Clase hace Referencia a la tabla de la db.
* Con la anotaci贸n `@Entity` declarada en cada Clase indic谩ndole a Spring que es una Entidad.
* Con la anotaci贸n `@GeneratedValue(strategy = GenerationType.IDENTITY)` en el campo id se indica el auto_increment
* Con la anotaci贸n `@Id` le indicamos que es el campo id de la db.
* Con la anotaci贸n `@Column(name="nombreDelCampoDeLaClase")` le indicamos que es un campo de la Clase.
* C贸digo Completo Clase Producto..

```java 
package com.api.productos.mypackages.entities;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Table(name="productos")
@Entity
public class Producto implements Serializable{
	
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Id
	@Column(name="id")
	private int id;

	@Column(name="codigo")
	private String codigo;
	
	@Column(name="nombre")
	private String nombre;
	
	@Column(name="precio")
	private float precio;
	
	
	
	
	
	public Producto() {
	}
	

	public Producto(String codigo, String nombre, float precio) {
		super();
		this.codigo = codigo;
		this.nombre = nombre;
		this.precio = precio;
	} 
	

	public Producto(int id, String codigo, String nombre, float precio) {
		super();
		this.id = id;
		this.codigo = codigo;
		this.nombre = nombre;
		this.precio = precio;
	}





	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getCodigo() {
		return codigo;
	}

	public void setCodigo(String codigo) {
		this.codigo = codigo;
	}

	public String getNombre() {
		return nombre;
	}

	public void setNombre(String nombre) {
		this.nombre = nombre;
	}

	public float getPrecio() {
		return precio;
	}

	public void setPrecio(float precio) {
		this.precio = precio;
	}
	
	
	

	@Override
	public String toString() {
		return "Producto [id=" + id + ", codigo=" + codigo + ", nombre=" + nombre + ", precio=" + precio + "]";
	}
	

}

```

 </br>

### Paso 7) Creaci贸n y Configuraci贸n de la Clase-Modelo Producto
#### ( Existen 2 Conceptualizaciones en este caso. La primera es que a una Clase se le llame Entidad-Modelo y la otra que exista la misma Clase definida como Modelo y Entidad (osea 2 clases casi identicas). Varios prefieren usar la primera o la segunda dependiendo c煤al sea la finalidad (ahorrar tiempo de c贸digo, modularizar el c贸digo o lo que sea). Yo opt茅 por la segunda ya que si bien es verdad que se tiene que generar m谩s c贸digo, cuando el mismo crezca los problemas van a tener un alcance m谩s controlado).
#### ( Las Entidades se trabajan en los Repositorios y los Modelos en los Controladores o Service )


</br>

#### 7.1) Creaci贸n de la Clase `ProductoModel`

* Creamos un paquete llamado mypackages.models dentro de com.api.productos (src/main/java/com.api.productos). Es importante que este dentro del mismo ya que sino Spring no desplegar谩 la app de forma correcta.
	* --> Click Der sobre la ruta mencionada  
	* --> New --> Package
	* --> En Name seguido de com.api.productos colocamos mypackages.models (com.api.productos.mypackages.models)
	* --> Finish

* Creamos la Clase-Modelo Producto
 	* --> Click Der sobre el paquete creado
 	* --> New --> Class
 	* --> Siempre asegurarse la ruta de creaci贸n a trav茅s del Source Folder y Package
 	* --> En Name colocamos ProductoModel
 	* --> Finish


```java
package com.api.productos.mypackages.models;

public class ProductoModel {

}

```


</br>

#### 7.2) Configuraci贸n de la Clase `ProductoModel`

* Vamos a copiar todo de la clase-entidad Producto ya creada excluyendo las anotaciones 
* La conversi贸n de una entidad a modelo lo podemos hacer instanciando un objeto de la clase entidad a trav茅s de la clase modelo
* Crearemos un constructor dentro de la clase ProductoModel que instancie dicho objeto de la clase entidad Producto
* C贸dido Constructor

```java
	/*
		 * @version 1.0
		 * 
		 * Instancia de la clase-entidad Producto
		 * @param producto
		 * */
		public ProductoModel(Producto producto) {
			this.id = producto.getId();
			this.nombre = producto.getNombre();
			this.codigo = producto.getCodigo();
			this.precio = producto.getPrecio();
			
		}

```

* C贸digo Completo

```java
package com.api.productos.mypackages.models;

import com.api.productos.mypackages.entities.Producto;

public class ProductoModel {

	
		private int id;

		private String codigo;
		
		private String nombre;
		
		private float precio;
		
		
		public ProductoModel() {
		}
		

		public ProductoModel(String codigo, String nombre, float precio) {
			super();
			this.codigo = codigo;
			this.nombre = nombre;
			this.precio = precio;
		} 
		

		public ProductoModel(int id, String codigo, String nombre, float precio) {
			super();
			this.id = id;
			this.codigo = codigo;
			this.nombre = nombre;
			this.precio = precio;
		}
		
		/*
		 * @version 1.0
		 * 
		 * Instancia de la clase-entidad Producto
		 * @param producto
		 * */
		public ProductoModel(Producto producto) {
			this.id = producto.getId();
			this.nombre = producto.getNombre();
			this.codigo = producto.getCodigo();
			this.precio = producto.getPrecio();
			
		}




		
		public int getId() {
			return id;
		}

		public void setId(int id) {
			this.id = id;
		}

		public String getCodigo() {
			return codigo;
		}

		public void setCodigo(String codigo) {
			this.codigo = codigo;
		}

		public String getNombre() {
			return nombre;
		}

		public void setNombre(String nombre) {
			this.nombre = nombre;
		}

		public float getPrecio() {
			return precio;
		}

		public void setPrecio(float precio) {
			this.precio = precio;
		}
		
		
		

		@Override
		public String toString() {
			return "Producto [id=" + id + ", codigo=" + codigo + ", nombre=" + nombre + ", precio=" + precio + "]";
		}
		

	}





```

</br>

## Secci贸n 5)  Creaci贸n y Configuraci贸n de las Interfaces Repositories y Convertidores de Clases  


</br>

 ### Paso 8) Creaci贸n y Configuraci贸n de la Interfaz-Repository Producto
 #### (Vamos a trabajar con el Patr贸n de Dise帽o DAO para la persistencia de los datos en la db. Al fin y al cabo la arquitectura dao nos suministra las interfaces para poder usar los m茅todos CRUD sin necesidad de duplicar c贸digo. Las interfaces dise帽adas van a contener los m茅todos CRUD sin necesidad de implementarlos y definir su cuerpo en una clase repository ya que vamos a implementar Spring Data JpaRepository. Esta API trae todos los m茅todos desarrollados )

</br>


#### 8.1) Creaci贸n de la Interfaz `I_ProductoRepository`
* Primeramente vamos a crear el paquete que alojar谩n las interfaces repositories con los m茅todos CRUD.
* Creamos un paquete llamado mypackages.repositories.repositories.interfaces dentro de com.api.productos (src/main/java/com.api.productos). Es importante que este dentro del mismo ya que sino Spring no desplegar谩 la app de forma correcta.
	* --> Click Der sobre la ruta mencionada  
	* --> New --> Package
	* --> En Name seguido de com.api.productos colocamos mypackages.repositories.interfaces (com.api.productos.mypackages.repositories.interfaces)
	* --> Finish

* Creamos la Interfaz I_ProductoRepository 
 	* --> Click Der sobre el paquete creado
 	* --> New --> Interface
 	* --> Siempre asegurarse la ruta de creaci贸n a trav茅s del Source Folder y Package
 	* --> En Name colocamos I_ProductoRepository
 	* --> Finish

```java

package com.api.productos.mypackages.interfaces;

public interface I_ProductoRepository {

}


```
</br>


#### 8.2) Configuraci贸n de la Interfaz `I_ProductoRepository`
#### (Vamos a trabajar con los repositorios de datos de Spring, estos nos van a ayudar a simplificar de forma significativa el c贸digo desarrollado).

</br>

* Vamos a crear m茅todos abstractos usando la serializaci贸n de Spring (conversi贸n de objetos Java a bytes).
* Recordar que los m茅todos abstractos son m茅todos que no tienen cuerpo, justamente por que ya est谩 definido dentro de Spring Boot. Estos m茅todos vienen en las clases que Spring descarga cuando se declara la dependencia de spring-data-jpa dentro del pom.
* Recomiendo la siguiente documentaci贸n `https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html`
* Para poder declarar la serializaci贸n de dichos objetos hay que heredar esta cualidad de jpa-repository  `JpaRepository<"entidadSinComas", Serializable>`
* Adem谩s vamos a declarar una anotaci贸n diciendole a Spring Boot que ser谩 un repositorio con la anotaci贸n `@Repository("nombreSinComillas")`
* C贸digo Snippet...
```java
package com.api.productos.mypackages.repositories.interfaces;

import java.io.Serializable;

import org.springframework.data.jpa.repository.JpaRepository;

import org.springframework.stereotype.Repository;

import com.api.productos.mypackages.entities.Producto;


@Repository("I_ProductoRepository")
public interface I_ProductoRepository extends JpaRepository<Producto, Serializable>{


	
}


```
* Seguido de esto vamos a definir los m茅todos a utilizar
* El primer m茅todo ser谩 para traer el producto por el id pedido.
```java

public abstract Producto findById(int id);

```
* El segundo, tercer y cuarto  m茅todo ser谩n listas, ya que los nombres y precios pueden ser repetidos 
```java

public abstract List<Producto> findByCodigo(String codigo);

public abstract List<Producto> findByNombre(String nombre);

public abstract List<Producto> findByPrecio(double precio);

```
* Vamos a trabajar con paginaci贸n, por ende mantenemos todos los m茅todos como List y no ArrayList
* Para el Quinto vamos a trabajar con Paginaci贸n 
* La Paginaci贸n es necesaria para evitar que la consulta a la API se sobrecargue, causando un timeout al utilizar la solicitud dada. Para todos los servicios que devuelven grandes cantidades de datos, siempre se debe utilizar la paginaci贸n para devolver los registros.
* La Interfaz I_ProductoRepository va a heredar la paginaci贸n de una clase y esta se debera serializar (transformar el objeto java en flujos de bytes para enviarlos).
* Dentro de la interfaz mencionada vamos a heredar de la clase PaginAndSortingRepository<Producto,Serializable>
* C贸digo Snippet..

```java
@Repository("I_ProductoRepository")
public interface I_ProductoRepository extends JpaRepository<Producto, Serializable>, PagingAndSortingRepository<Producto,Serializable>{

...

}

```
* Dentro de esta interfaz vamos a crear otro M茅todo sobrecargado llamado `findAll` que ser谩 `Page` de tipo Producto, este m茅todo se le pasar谩 como parametro un objeto de tipo `Pageable`....bue...osea que es un objeto paginado, a su vez este m茅todo se implemenatr谩 a traves de JPA-Hibernate (Recordar que las convenciones de nombres en la interfaz implementando este Framework hay que respetarlas, sino surgiran errores a la larga). 
* ATENTI que clase se importe, para este caso, todo de `org.springframework.data.domain`
* C贸digo Snippet..

```java
public abstract Page<Producto> findAll(Pageable pageable);

	
```
* C贸digo Completo..

```java
package com.api.productos.mypackages.repositories.interfaces;

import java.io.Serializable;
import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.repository.PagingAndSortingRepository;
import org.springframework.stereotype.Repository;

import com.api.productos.mypackages.entities.Producto;


@Repository("I_ProductoRepository")
public interface I_ProductoRepository extends JpaRepository<Producto, Serializable>, PagingAndSortingRepository<Producto, Serializable>{

//Hay M茅todos que JPA ya los tiene desarrollados, se pueden crear para tener
//una manipulaci贸n m谩s especifica a la hora de usarlos en el service	

public abstract Producto findById(int id);

public abstract List<Producto> findByCodigo(String codigo);

public abstract List<Producto> findByNombre(String nombre);

public abstract List<Producto> findByPrecio(float precio);

public abstract Page<Producto> findAll(Pageable pageable);
	
	
}


```

</br>


### 8.3) Configuraci贸n de la Paginaci贸n en el `application.properties`

* Copiar las siguientes propiedades y pegarlas en el `application.properties`

```xml
spring.data.rest.page-param-name=page
spring.data.rest.sort-param-name=sort
spring.data.rest.limit-param-name=limit
spring.data.rest.default-page-size = 5
spring.data.rest.max-page-size = 20

```
* La primera propiedad hace referencia al nombre del primer parametro de la paginaci贸n
* La segunda propiedad spring ordena la consulta
* Con la tercera establecemos un limite de registros por paginaci贸n
* La Cuarta Propiedad indicamos la cantidad de p谩ginaciones por defecto
* La Quinta la cantidad m谩xima de paginaciones

</br>




 ### Paso 9) Creaci贸n y Configuraci贸n de la Clase Converter 
 #### ( Adem谩s de implementar el patr贸n de dise帽o DAO para el manejo de los datos en la db, se implementa el patr贸n MVC. En este caso desarrollando una Clase Converter vamos a poder convertir las entidades en modelos, y de esa forma poder trabajar con Hibernate en la Clase Modelo y no en la Clase Entidad )

</br>

#### 9.1) Creaci贸n de la Clase `ProductoConverter`
* Primeramente vamos a crear el paquete que alojar谩n las clases Converter.
* Creamos un paquete llamado mypackages.converters dentro de com.api.productos (src/main/java/com.api.productos). Es importante que este dentro del mismo ya que sino Spring no desplegar谩 la app de forma correcta.
	* --> Click Der sobre la ruta mencionada  
	* --> New --> Package
	* --> En Name seguido de com.api.productos colocamos mypackages.converters (com.api.productos.mypackages.converters)
	* --> Finish

* Creamos la Clase Converter
 	* --> Click Der sobre el paquete creado
 	* --> New --> Clase
 	* --> Siempre asegurarse la ruta de creaci贸n a trav茅s del Source Folder y Package
 	* --> En Name colocamos ProductoConverter
 	* --> Finish



```java
package com.api.productos.mypackages.converters;

public class ProductoConverter {

}



```

</br>

#### 9.2) Configuraci贸n de la Clase `ProductoConverter`
* Primeramente vamos a incluir la anotaci贸n `@Component("ProductoComponent")`.
* La anotaci贸n `@Component` marca la clase Java como un bean o componente para que el mecaniso de exploraci贸n de componentes de Spring pueda agregarla al contexto de la aplicaci贸n.
* Seguidamente vamos a construir el cuerpo de la clase con los m茅todos que modelizaremos para la conversi贸n de entidades a modelos.
* C贸digo Snippet..
```java

package com.api.productos.mypackages.converters;

import org.springframework.stereotype.Component;

@Component("ProductoConverter")
public class ProductoConverter {

}

```



</br>


#### 9.2.1) Creaci贸n del M茅todo `convertirListaProducto` de tipo `List`
#### (Este M茅todo se va a encargar de convertir una lista de tipo Producto Entidad a otra de Tipo Producto Modelo. Para este caso voy a utilizar una lista de tipo List porque al momento ded trabajar con paginaci贸n es m谩s f谩cil su uso. Es evidente que se podr铆a usar ArrayList ya que es mucho m谩s eficiente que una List cuando se realizan muchos accesos pero me trajo algunos inconvenientes ya que las clases que se implementan en la paginaci贸n no son tan modernas)

</br>

* El M茅todo es de tipo Lista, se le pasa una Lista de Productos de tipo Producto Entidad y nos devuelve una Lista de Tipo Modelo Producto.
* Pero para realizar tal conversi贸n se usar谩 un for each, el for each va a convertir todos los objetos de la lista Entidad a una lista de objetos de la clase Modelo.
* C贸digo Snippet..

```java
	
	public List<ProductoModel> convertirListaProducto(List<Producto> list){
		
		List<ProductoModel> listaModeloProductos = new ArrayList<>();
	
		
		list.forEach(objetoProducto -> listaModeloProductos.add(new ProductoModel(objetoProducto)));
		
		return listaModeloProductos;
	
	}

```




</br>



## Secci贸n 6) Creaci贸n y Configuraci贸n de los Services



</br>

 ### Paso 10) Creaci贸n y Configuraci贸n de la Clase Service
 #### (La Clase Service (Componente de Servicio) nos va a permitir gestionar la l贸gica empresarial en una capa diferente. )

</br>

#### Paso 10.1) Creaci贸n de la Clase `ProductoService`
* Primeramente vamos a crear el paquete que alojar谩 el Service.
* Creamos un paquete llamado mypackages.service dentro de com.api.productos (src/main/java/com.api.productos). Es importante que este dentro del mismo ya que sino Spring no desplegar谩 la app de forma correcta.
	* --> Click Der sobre la ruta mencionada  
	* --> New --> Package
	* --> En Name seguido de com.api.productos colocamos mypackages.service (com.api.productos.mypackages.service)
	* --> Finish

* Creamos la Clase Service
 	* --> Click Der sobre el paquete creado
 	* --> New --> Clase
 	* --> Siempre asegurarse la ruta de creaci贸n a trav茅s del Source Folder y Package
 	* --> En Name colocamos ProductoService
 	* --> Finish
* C贸digo Snippet..



```java
package com.api.productos.mypackages.service;

public class ProductoService {

}

```

</br>



#### Paso 10.2) Configuraci贸n de la Clase `ProductoService`
* En esta Clase Service se implementar谩 Inyecci贸n de Dependencias, esta nos permite relacionar objetos. Todas las dependencias se encuentran en un contenedor, que ser谩 el responsable de inyectarlas y crear los beans (Clases de tipo objetos) necesarios.
* Primeramente vamos a incluir la anotaci贸n `@Service("ProductoService")`.
* La anotaci贸n `@Service` se encarga de registrar el componente y permiter que se inyecten otras clases a 茅l.
* C贸digo Snippet..

```java
package com.api.productos.mypackages.service;

@Service("ProductoService")
public class ProductoService {

}


```

</br>

#### Paso 10.2) Inyecci贸n de Dependendencias de la Clase `ProductoService`

* Vamos a definir las inyecciones de Dependencia de la clase que al fin y al cabo ser谩n la Interfaz creada, el Convertidor, etc. Todo relacionado mediante el Service creado
* Dentro de la Clase vamos a usar la anotaci贸n `@Autowired` para la relaci贸n de los Beans e Interfaces.
* Seguidamente vamos a hacer uso de la notaci贸n `@Qualifier("NombreBean")` para nombrar y relacionar el Bean que vamos a definir dentro del servicio
* Creamos el campo-atributo que har谩 referencia a la interfaz bean.
* C贸digo Snippet..
```java

	@Autowired
	@Qualifier("I_ProductoRepository")
	private I_ProductoRepository iProductoRepository;

}


```
* Ahora creamos el campo que usaremos que ser谩 el Bean Clase Controler. 
* Vamos a implementar las mismas anotaciones cambiando el nombre del bean logicamente.
* C贸digo Snippet..
```java
	@Autowired
	@Qualifier("ProductoConverter")
	private ProductoConverter productoConvertidos;

```

</br>

* C贸digo Completo..
```java
package com.api.productos.mypackages.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import com.api.productos.mypackages.converters.ProductoConverter;
import com.api.productos.mypackages.repositories.interfaces.I_ProductoRepository;

@Service("ProductoService")
public class ProductoService {
	
	@Autowired
	@Qualifier("I_ProductoRepository")
	private I_ProductoRepository iProductoRepository;

	
	@Autowired
	@Qualifier("ProductoConverter")
	private ProductoConverter productoConvertidor;

}


```

</br>

#### Paso 10.3) M茅todos CRUD de la Clase `ProductoService`
#### (Ac谩 vamos a definir los m茅todos que se encarguen de traer toda la l贸gica de persistencia del repositorio del Producto, como lo son listar, agregar, editar y eliminar alg煤n producto)


</br>

#### 10.3.1) Creaci贸n del M茅todo `agregarProducto`
* Este M茅todo va a persistir un Producto en la db a trav茅s de la Interfaz creada implementando jpa y declarada en este service.
* El M茅todo deevuelve un booleano, si hace lo requerido devuelve true, si el objeto es nulo false y sino false.
* Dentro del M茅todo, utilizando la interfaz creada vamos a invocar al m茅todo `save()` de JPA para persistir el producto en la db.
* Notar que se puede crear otro m茅todo en la interfaz con otro nombre que haga exactamente lo mismo que el m茅todo save de jpa, queda a criterio de cada uno
* C贸dido Snippet..

```java
//INSERT
	public boolean agregarProducto(Producto producto) {
		
		try {
			
			if (producto == null) {
				
				return false;
					
			}else {
				
				iProductoRepository.save(producto);
				
				return true;
			
			}
		
			
		}catch(Exception e) {
			return false;
		}
	}

```



</br>

#### 10.3.2) Creaci贸n del M茅todo `editarProducto`
* Este M茅todo va a actualizar y persistir un Producto en la db a trav茅s de la Interfaz creada implementando jpa y declarada en este service.
* El M茅todo devuelve un booleano, si hace lo requerido devuelve true, si el objeto es nulo o el id es 0 false y sino tambi茅n false.
* Aplicamos el mismo m茅todo save de jpa

```java

//UPDATE
		public boolean editarProducto(Producto producto) {
			
			try {
				
				if ((producto == null) || (producto.getId() == 0)) {
					
					return false;
						
				}else {
					
					iProductoRepository.save(producto);
					
					return true;
				
				}
			
				
			}catch(Exception e) {
				return false;
			}
		}


```


</br>

#### 10.3.3) Creaci贸n del M茅todo `eliminarProducto`
* Este M茅todo va a eliminar un Producto de la db a trav茅s de la Interfaz creada implementando jpa y declarada en este service.
* El M茅todo devuelve un booleano, si hace lo requerido devuelve true, si el id es 0 false y sino tambi茅n false.
* Vamos a invocar el m茅todo creado en la interfaz llamado `findById()` para eliminar el producto a traves del id que se le pase a artaves del argumento de este metodo.
* Una vez que jpa encuentra este id, lo eliminamos con el m茅todo de jpa `delete()` 

```java

//DELETE
	public boolean eliminarProducto(int id) {
					
			try {
						
				if ((id == 0)) {
							
					return false;
								
				}else {
							
					Producto idProducto = iProductoRepository.findById(id);
							
					iProductoRepository.delete(idProducto);
					
					
					return true;
						
				}
					
						
				}catch(Exception e) {
						return false;
					}
				}
```




</br>

#### 10.3.3) Creaci贸n del M茅todo `listadoProductos`
* Este M茅todo nos va a traer uno o varios Producto/s como lista de productos del ModeloProducto y NO de la Entidad Producto
* Para poder realizar esto llamamos al `Convertidor`
* ATENTI a esto, la lista devuelta por el m茅todo sera del Modelo y No de la Entidad
* El M茅todo ser谩 de tipo List y no ArrayList por el uso de la paginaci贸n mencionada
* Vamos a invocar al M茅todo que convierte la lista Entidad a Modelo de Productos a traves del convertidor
* Dentro del Convertidor vamos a implementar el metodo `findAll()` invocandolo cno la interfaz.
* Notar que se puede crear otro m茅todo en la interfaz con otro nombre que haga exactamente lo mismo que el m茅todo save de jpa, queda a criterio de cada uno.
* Vamos a devolver un return con la lista de Productos.
* ATENTI que clase se importe, para este caso, todo de `org.springframework.data.domain`
* C贸digo Snippet..
```java
//LISTA DE PRODUCTOS
	public List<ProductoModel> listadoProductos(Pageable pageable){
		
		return  productoConvertidor.convertirListaProducto( iProductoRepository.findAll(pageable).getContent()); 
		
	}
	

```


* C贸digo Completo M茅todos CRUD..
```java

	
	//===================== MTODOS CRUD ===========================
	
	//INSERT
	public boolean agregarProducto(Producto producto) {
		
		try {
			if (producto == null) {return false;}
			
			else {
				iProductoRepository.save(producto);
				return true;}
		
			
		}catch(Exception e) {return false;}
	}
	
	
	
	//UPDATE
	public boolean editarProducto(Producto producto) {
			
			try {
				
				if ((producto == null) || (producto.getId() == 0)) {
					
					return false;}
				
				else {	
					iProductoRepository.save(producto);
					return true;}
			
				
			}catch(Exception e) {return false;}
		}
	
	//DELETE
	public boolean eliminarProducto(int id) {
					
			try {
						
				if ((id == 0)) {return false;}
				
				else {
							
					Producto idProducto = iProductoRepository.findById(id);
							
					iProductoRepository.delete(idProducto);

					return true;}
					
						
				}catch(Exception e) {return false;} 
	}
	
	
	
	//LISTA DE PRODUCTOS
	public ArrayList<ProductoModel> listadoProductos(Pageable pageable){
		
		return  productoConvertidor.convertirListaProducto((ArrayList<Producto>) iProductoRepository.findAll(pageable).getContent()); 
		
	}
	

	

```



</br>

#### Paso 10.4) M茅todos de B煤squeda de la Clase `ProductoService`
#### (Ac谩 vamos a definir los m茅todos que se encarguen de traer los objetos de la db pero seg煤n los campos que le pasemos como argumento de la funcion creada. Vamos a utilizar los mismos nombres que los metodos creados en la Interfaz)



</br>

#### 10.4.1) Creaci贸n del M茅todo `findById`
* Este M茅todo nos va a traer el Producto con el Id pedido. 
* Es importante aclarar que el m茅todo es de tipo Modelo y no Entidad
* Para poder realizar esto llamamos al m茅todo creado `findById` a traves de la interfaz
* El M茅todo nos va a crear y devolver un Producto con el  id pasado. 
* ATENTI a esto, la lista devuelta por el m茅todo sera del Modelo y No de la Entidad

				
```java

//PRODUCTO POR ID
	public ModeloProducto findById(int id) {
		
		return new ModeloProducto(iProductoRepository.findById(id));
		
	}
				
```

</br>

#### 10.4.2) Creaci贸n del M茅todo `findByCodigo`
* Este M茅todo nos va a traer el Producto, o los productos con el codigo pedido.
* Se podr铆a cuestionar si el c贸digo es unico, pero en este caso se lo trabaja como lista  
* Es importante aclarar que el m茅todo es de tipo Modelo y no Entidad
* Para poder realizar esto llamamos al m茅todo creado `findByCodigo` a traves de la interfaz
* El M茅todo nos va a crear y devolver uno o varios Producto/s con el codigo pasado. 
* ATENTI a esto, la lista devuelta por el m茅todo sera del Modelo y No de la Entidad

				
```java

	//PRODUCTO POR CODIGO
	public List<ProductoModel> findByCodigo(String codigo) {
		
		return productoConvertidor.convertirListaProducto(iProductoRepository.findByCodigo(codigo));
	}
		
				
```


</br>

#### 10.4.3) Creaci贸n del M茅todo `findByNombre`
* Este M茅todo nos va a traer uno o varios Producto/s como lista a traves de el nombre pedido. 
* Es importante aclarar que el m茅todo es de tipo Modelo y no Entidad
* Trabajando con el converter convertimos la lista de Entidad a lista de Modelo
* Para poder realizar esto llamamos al m茅todo creado `findByNombre` a traves de la interfaz
* El M茅todo nos va a devolver uno o varios Producto/s como lista . 
* ATENTI a esto, la lista devuelta por el m茅todo sera del Modelo y No de la Entidad

				
```java

	
	//LISTA DE PRODUCTOS POR NOMBRE
	public List<ProductoModel> findByNombre(String nombre){
		
		return productoConvertidor.convertirListaProducto(iProductoRepository.findByNombre(nombre)); 
		
	}
				
```


</br>

#### 10.4.4) Creaci贸n del M茅todo `findByPrecio`
* Este M茅todo nos va a traer uno o varios Producto/s como lista a traves de el precio pedido. 
* Es importante aclarar que el m茅todo es de tipo Modelo y no Entidad
* Trabajando con el converter convertimos la lista de Entidad a lista de Modelo
* Para poder realizar esto llamamos al m茅todo creado `findByPrecio` a traves de la interfaz
* El M茅todo nos va a devolver uno o varios Producto/s como lista . 
* ATENTI a esto, la lista devuelta por el m茅todo sera del Modelo y No de la Entidad

				
```java

	//LISTA DE PRODUCTOS POR PRECIO
	public List<ProductoModel> findByPrecio(float precio){
		
		return productoConvertidor.convertirListaProducto(iProductoRepository.findByPrecio(precio)); 
		
	}
	
				
```
* C贸digo Completo M茅todos de Uso..

```java


	
	
	
	//================ METODOS DE BUSQUEDA =============================
	
	
	//PRODUCTO POR ID | VALOR UNICO
	public ProductoModel findById(int id) {
		
		return new ProductoModel(iProductoRepository.findById(id));
		
	}
	
	//PRODUCTO POR CODIGO
	public List<ProductoModel> findByCodigo(String codigo) {
		
		return productoConvertidor.convertirListaProducto(iProductoRepository.findByCodigo(codigo));
	}
		
	
	//LISTA DE PRODUCTOS POR NOMBRE
	public List<ProductoModel> findByNombre(String nombre){
		
		return productoConvertidor.convertirListaProducto(iProductoRepository.findByNombre(nombre)); 
		
	}
	
	//LISTA DE PRODUCTOS POR PRECIO
	public List<ProductoModel> findByPrecio(float precio){
		
		return productoConvertidor.convertirListaProducto(iProductoRepository.findByPrecio(precio)); 
		
	}
	

	
	

	

	
	
```

</br>


#### 10.4.5) Creaci贸n de Logs de Error
#### (Es una buena pr谩ctica utilizar logs. Los Logs son Registros(archivos de historial) que nos ayudan a la hora de identificar un posible error, advertencias, actividades realizadas,etc. Nos es recomendable utilizar varios m茅todos logs, ya que el espacio del servidor podr铆a colapsar. El M茅todo m谩s utilizado es el de error. )

</br>

* Vamos a implementar los logs dentro del service, ya que all铆 es donde se encuentra toda la l贸gica de persistencia de datos.
* Creamos una variable llamada logger de tipo `Logger` del paquete 
`org.apache.logging.log4j.Logger` , y vamos a inicializarla pasandole la clase ProductoService
```java

	//==================== LOGS ============================
	
	//LOGS DE ERROR
	private static final Logger logger = org.apache.logging.log4j.LogManager.getLogger(ProductoService.class);
	
	

```
	
* Para implementar dicho log, habr谩 que invocar el m茅todo error `.error("mensaje")` a trav茅s del objeto de la clase. Dicha implementaci贸n deber谩 ser estar antes que el return
* Se implementar谩 un log por m茅todo creado del Service
* C贸digo Completo..

```java
package com.api.productos.mypackages.service;

import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import com.api.productos.mypackages.converters.ProductoConverter;
import com.api.productos.mypackages.entities.Producto;
import com.api.productos.mypackages.models.ProductoModel;
import com.api.productos.mypackages.repositories.interfaces.I_ProductoRepository;


@Service("ProductoService")
public class ProductoService {
	
	// ========= INYECCIN DE DEPENDENCIAS ==========
	@Autowired
	@Qualifier("I_ProductoRepository")
	private I_ProductoRepository iProductoRepository;

	
	@Autowired
	@Qualifier("ProductoConverter")
	private ProductoConverter productoConvertidor;
	
	
	
	//==================== LOGS ============================
	
	//LOGS DE ERROR
	private static final Logger logger = org.apache.logging.log4j.LogManager.getLogger(ProductoService.class);
	
	
	
	
	//===================== MTODOS CRUD ===========================
	
	//INSERT
	public boolean agregarProducto(Producto producto) {
		
		try {
			if (producto == null) {
				logger.error("ERROR AGREGAR_PRODUCTO: EL PRODUCTO ES NULO!");
				return false;				
			}
			
			else {
				iProductoRepository.save(producto);
				return true;
				
			}
		
			
		}catch(Exception e) {
			logger.error("ERROR AGREGAR_PRODUCTO: EL PRODUCTO NO SE HA GUARDADO!");
			return false;
			
			
		}
	}
	
	
	
	//UPDATE
	public boolean editarProducto(Producto producto) {
			
			try {
				
				if ((producto == null) || (producto.getId() == 0)) {
					logger.error("ERROR EDITAR_PRODUCTO:  EL PRODUCTO ES NULO O EL ID ES 0!");		
					return false;
					
				}
				
				else {	
					iProductoRepository.save(producto);
					return true;
					
				}
			
				
			}catch(Exception e) {
				logger.error("ERROR EDITAR_PRODUCTO: EL PRODUCTO NO SE HA EDITADO!");		
				return false;
				
			}
		}
	
	//DELETE
	public boolean eliminarProducto(int id) {
					
			try {
						
				if ((id == 0)) {
					logger.error("ERROR ELIMINAR_PRODUCTO: EL ID DEL PRODUCTO ES 0!");
					return false;
				}
				
				else {
							
					Producto idProducto = iProductoRepository.findById(id);
							
					iProductoRepository.delete(idProducto);

					return true;
					}
					
						
				}catch(Exception e) {
					logger.error("ERROR ELIMINAR_PRODUCTO: EL PRODUCTO NO SE HA ELIMINADO!");
					return false;
					
				} 
	}
	
	
	//LISTA DE PRODUCTOS
	public List<ProductoModel> listadoProductos(Pageable pageable){
		
		return  productoConvertidor.convertirListaProducto( iProductoRepository.findAll(pageable).getContent()); 
		
	}
	

	
	
	
	
	
	
	//================ METODOS DE BUSQUEDA =============================
	
	
	//PRODUCTO POR ID | VALOR UNICO
	public ProductoModel findById(int id) {
		
		return new ProductoModel(iProductoRepository.findById(id));
		
	}
	
	//PRODUCTO POR CODIGO
	public List<ProductoModel> findByCodigo(String codigo) {
		
		return productoConvertidor.convertirListaProducto(iProductoRepository.findByCodigo(codigo));
	}
		
	
	//LISTA DE PRODUCTOS POR NOMBRE
	public List<ProductoModel> findByNombre(String nombre){
		
		return productoConvertidor.convertirListaProducto(iProductoRepository.findByNombre(nombre)); 
		
	}
	
	//LISTA DE PRODUCTOS POR PRECIO
	public List<ProductoModel> findByPrecio(float precio){
		
		return productoConvertidor.convertirListaProducto(iProductoRepository.findByPrecio(precio)); 
		
	}
	


	

}


```
* Para el testeo de los logs, usar postman y pasarle un id 0 al m茅todo put de edici贸n de productos o enviar un objeto vac铆o. Se deber铆an mostrar los respectivos mensajes en la consola de spring.




</br>

 ### Paso 11) Creaci贸n y Configuraci贸n de la Clase Controller
 #### (La Clase Controller es la que se encarga de preparar el Modelo(el Modelo son los datos manejados por la aplicaci贸n) y seleccionar el nombre de la vista que ser谩 utilizada para mostrar el modelo al cliente. Esta Clase ejecuta la l贸gica de negocio, obtiene los resultados y los devuelve al servlet, encapsulado en un objeto de tipo Model)

</br>

#### Paso 11.1) Creaci贸n de la Clase `ProductoController`
* Primeramente vamos a crear el paquete que alojar谩 el Controller.
* Creamos un paquete llamado mypackages.controller dentro de com.api.productos (src/main/java/com.api.productos). Es importante que este dentro del mismo ya que sino Spring no desplegar谩 la app de forma correcta.
	* --> Click Der sobre la ruta mencionada  
	* --> New --> Package
	* --> En Name seguido de com.api.productos colocamos mypackages.controllers
	* --> Finish

* Creamos la Clase Controller
 	* --> Click Der sobre el paquete creado
 	* --> New --> Clase
 	* --> Siempre asegurarse la ruta de creaci贸n a trav茅s del Source Folder y Package
 	* --> En Name colocamos ProductoController
 	* --> Finish
* C贸digo Snippet..



```java
package com.api.productos.mypackages.controllers;

public class ProductoController {
	
	public static void main(String[] args) {
		
	}
}

```

</br>

</br>

#### Paso 11.2) Configuraci贸n de la Clase `ProductoController`
* Al igual que la Clase Service, en esta Clase Controller  se implementar谩 Inyecci贸n de Dependencias, esta nos permite relacionar objetos. Todas las dependencias se encuentran en un contenedor Spring, que ser谩 el responsable de inyectarlas y crear los beans (Clases de tipo objetos) necesarios.
* Para la Clase ProductoController vamos a Implementar la anotation `@RestController`. Con esta anotaci贸n le indicamos a Spring que esta clase ser谩 un componente de tipo controlador, adem谩s permitimos el manejo de solicitudes HTTP usando la API REST.  
* Tambi茅n Implementamos la anotaci贸n `@RequestMapping("rutaVersionadoApi")` que se va a encargar de relacionar un m茅todo con una petici贸n http.
* C贸digo Snippet..



```java
package com.api.productos.mypackages.controllers;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/v1")
public class ProductoController {
	


}
 

```

</br>

#### Paso 11.3) Inyecci贸n de Dependendencias de la Clase `ProductoController`

* Vamos a definir las inyecciones de Dependencia de la clase que al fin y al cabo ser谩 el Servicio creado.
* Dentro de la Clase vamos a usar la anotaci贸n `@Autowired` para la relaci贸n de los Beans e Interfaces.
* Seguidamente vamos a hacer uso de la notaci贸n `@Qualifier("NombreBean")` para nombrar y relacionar el Bean que vamos a definir dentro del controller
* C贸digo Snippet..
```java

	//INYECCION DEL SERVICE
	@Autowired
	@Qualifier("ProductoService")
	ProductoService productoService;
	
	


```
* C贸digo Snippet..
```java
package com.api.productos.mypackages.controllers;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.api.productos.mypackages.service.ProductoService;

@RestController
@RequestMapping("/v1")
public class ProductoController {
	
	//INYECCION DEL SERVICE
	@Autowired
	@Qualifier("ProductoService")
	ProductoService productoService;
	
	


}
 

```

</br>

#### Paso 11.4) M茅todos CRUD de la Clase `ProductoController`
#### (Ac谩 vamos a definir los m茅todos CRUD del Controller como lo son listar, agregar, editar y eliminar alg煤n producto. Los M茅todos CRUD del controller llevar谩n la anotaci贸n de M茅todos de Petici贸n(GET, HEAD, POST, PUT, ETC). Estos m茅todos nos permitar谩n trabajar con el Servicio RESTful )


</br>

#### 11.4.1) Creaci贸n del M茅todo `agregarProducto` mediante  `POST`
* Este M茅todo va a persistir un Producto en la db a trav茅s del Service Creado.
* El M茅todo va a tener la anotaci贸n `@PostMapping("ruta")`, este tipo de anotaci贸n ser谩 una propiedad de petici贸n http.
* La Petici贸n POST coloca un archivo en un URI(direcci贸n completa) especifico. Si hay un archivo o recurso en ese URI, POST reempleaza ese archivo o recurso. Si no hay ning煤n archivo o recurso, POST crea uno. A diferencia del M茅todo PUT, los datos no se muestran en el cach茅 ni tampoco en el historial de navegaci贸n.
* Dentro del argumento del m茅todo agregaremos las anotaciones `@RequestBody` y `@Validated`. La Primera nos permite recuperar el cuerpo de la solicitud y la segunda ejecuta validaciones para los m茅todos de una clase. 
* El M茅todo devuelve un booleano, si hace lo requerido devuelve true, sino false.
* Vamos a usar el Service inyectado en este Controller.
* Dentro del M茅todo, utilizando el Service creado vamos a invocar al m茅todo `agregarProducto()` creado en el mismo Service, junto con la l贸gica de persistencia para persistir el producto en la db.
* C贸dido Snippet..

```java
	//METODO POST
	@PostMapping("/producto")
	public boolean agregarProducto(@RequestBody @Validated Producto producto) {
		return productoService.agregarProducto(producto);
	}

```



</br>

#### 11.4.2) Creaci贸n del M茅todo `editarProducto` mediante  `PUT`
* Este M茅todo va a editar y luego persistir un Producto en la db a trav茅s del Service Creado.
* El M茅todo va a tener la anotaci贸n `@PutMapping("ruta")`, este tipo de anotaci贸n ser谩 una propiedad de petici贸n http.

* Dentro del argumento del m茅todo agregaremos las anotaciones `@RequestBody` y `@Validated`. La Primera nos permite recuperar el cuerpo de la solicitud y la segunda ejecuta validaciones para los m茅todos de una clase. 
* La Petici贸n PUT coloca un archivo en un URI(direcci贸n completa) especifico. Si hay un archivo o recurso en ese URI, PUT reempleaza ese archivo o recurso. Si no hay ning煤n archivo o recurso, PUT crea uno.
* El M茅todo devuelve un booleano, si hace lo requerido devuelve true, sino false.
* Vamos a usar el Service inyectado en este Controller.
* Dentro del M茅todo, utilizando el Service creado vamos a invocar al m茅todo `editarProducto()` creado en el mismo Service, junto con la l贸gica de persistencia para luego de editar persistir el producto en la db.
* `ATENTI`, este m茅todo es para editar un producto, por lo que el cuerpo de solicitud que se deba pasar a la hora de testear este m茅todo hay que incluir el id de ese producto. 
* C贸dido Snippet..

```java
	
	//MTODO PUT
	@PutMapping("/producto")
	public boolean editarProducto(@RequestBody @Validated Producto producto) {
		return productoService.editarProducto(producto);
		
	}

```



</br>

#### 11.4.3) Creaci贸n del M茅todo `eliminarProducto` mediante  `DELETE`
* Este M茅todo va a eliminar un Producto en la db a trav茅s del Service Creado.
* El M茅todo va a tener la anotaci贸n `@DeleteMapping("ruta")`, este tipo de anotaci贸n ser谩 una propiedad de petici贸n http delete.
* Vamos a incluir el id del producto dentro de la ruta que se le pase a la anotaci贸n, de esta forma podemos eliminar el producto por el id que le pasemos dentro de la URI completa
* Dentro del argumento del m茅todo agregaremos las anotaciones `@PathVariable("parametroDelMappping")` . Esta Anotaci贸n nos permite manejar las variables declaradas dentro del mapping para la asignaci贸n de la URI de la solicitud HTTP y establecerlas como parametros de metodo. 
* El M茅todo devuelve un booleano, si hace lo requerido devuelve true, sino false.
* Vamos a usar el Service inyectado en este Controller.
* Dentro del M茅todo, utilizando el Service creado vamos a invocar al m茅todo `eliminarProducto()` creado en el mismo Service, junto con la l贸gica de persistencia para luego de editar persistir el producto en la db. 
* C贸dido Snippet..

```java
	
//MTODO DELETE
	@DeleteMapping("/producto/{id}")
	public boolean eliminarProducto(@PathVariable("id") int id) {
		return productoService.eliminarProducto(id);
			
		}
```



</br>

#### 11.4.3) Creaci贸n del M茅todo `listadoProductos` mediante  `GET`
* Este M茅todo va a devolvernos una lista del ProductoModel con uno o m谩s Productos a trav茅s del Service Creado.
* El M茅todo va a tener la anotaci贸n `@GetMapping("ruta")`, este tipo de anotaci贸n ser谩 una propiedad de petici贸n http get. Es importante aclarar que la ruta ser谩 `/productos`
* El M茅todo devuelve una lista de tipo List y no ArrayList por el tema de paginaci贸n ya aclarado, esta lista es de tipo ProductoModel a trav茅s del m茅todo `listadoProductos` del Service creado y es de tipo pageable, osea nos va a paginar los productos para no devolvernos todos
* C贸digo Snippet..

```java

	//MTODO GET
	@GetMapping("/productos")
	public List<ProductoModel> listadoProductos(Pageable pageable){
		return productoService.listadoProductos(pageable);
	}
	
	


```


</br>

#### 11.4.3) Creaci贸n de los M茅todos de B煤squeda por campos mediante  `GET`
* Los M茅todos de B煤squeda por campo ser谩n aquellos que nos devuelvan un objeto o una lista de objetos seg煤n el campo de inter茅s, como por ejemplo podemos buscar aquellos productos que tengan cierto nombre o cierto c贸digo, o mismo a trav茅s de su id. Todos los m茅todos de b煤squeda comenzar谩n con las siglas `getBy....`
* C贸digo Snippet..

```java
	// ==============MTODOS HTTP DE BSQUEDA =============

	// ---GET---
	@GetMapping("/productos/id/{id}")
	public ProductoModel getById(@PathVariable("id") int id) {

		return productoService.findById(id);
	}

	// ---GET---
	@GetMapping("/productos/codigo/{codigo}")
	public List<ProductoModel> getByCodigo(@PathVariable("codigo") String codigo) {

		return productoService.findByCodigo(codigo);
	}

	// ---GET---
	@GetMapping("/productos/nombre/{nombre}")
	public List<ProductoModel> getByNombre(@PathVariable("nombre") String nombre) {

		return productoService.findByNombre(nombre);
	}

	// ---GET---
	@GetMapping("/productos/precio/{precio}")
	public List<ProductoModel> getByPrecio(@PathVariable("precio") float precio) {

		return productoService.findByPrecio(precio);
	}


```



</br>

* C贸digo Completo..
```java
package com.api.productos.mypackages.controllers;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.domain.Pageable;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.api.productos.mypackages.entities.Producto;
import com.api.productos.mypackages.models.ProductoModel;
import com.api.productos.mypackages.service.ProductoService;

@RestController
@RequestMapping("/v1")
public class ProductoController {

	// ==========INYECCION DEL SERVICE==========
	@Autowired
	@Qualifier("ProductoService")
	ProductoService productoService;

	// ==========MTODOS HTTP====================

	// METODO POST
	@PreAuthorize("hasRole('ADMINISTRADOR')")
	@PostMapping("/producto")
	public boolean agregarProducto(@RequestBody @Validated Producto producto) {
		return productoService.agregarProducto(producto);
	}

	// MTODO PUT
	@PreAuthorize("hasRole('ADMINISTRADOR')")
	@PutMapping("/producto")
	public boolean editarProducto(@RequestBody @Validated Producto producto) {
		return productoService.editarProducto(producto);

	}

	// MTODO DELETE
	@PreAuthorize("hasRole('ADMINISTRADOR')")
	@DeleteMapping("/producto/{id}")
	public boolean eliminarProducto(@PathVariable("id") int id) {
		return productoService.eliminarProducto(id);

	}

	// MTODO GET
	@GetMapping("/productos")
	public List<ProductoModel> listadoProductos(Pageable pageable) {
		return productoService.listadoProductos(pageable);
	}

	// ==============MTODOS HTTP DE BSQUEDA =============

	// ---GET---
	@GetMapping("/productos/id/{id}")
	public ProductoModel getById(@PathVariable("id") int id) {

		return productoService.findById(id);
	}

	// ---GET---
	@GetMapping("/productos/codigo/{codigo}")
	public List<ProductoModel> getByCodigo(@PathVariable("codigo") String codigo) {

		return productoService.findByCodigo(codigo);
	}

	// ---GET---
	@GetMapping("/productos/nombre/{nombre}")
	public List<ProductoModel> getByNombre(@PathVariable("nombre") String nombre) {

		return productoService.findByNombre(nombre);
	}

	// ---GET---
	@GetMapping("/productos/precio/{precio}")
	public List<ProductoModel> getByPrecio(@PathVariable("precio") float precio) {

		return productoService.findByPrecio(precio);
	}

	
}

 
```




</br>

 ### Paso 12) Test de los M茅todos CRUD de la Clase `ProductoController`
 #### (Vamos a realizar el testeo de cada uno de los m茅todos del controller de nuestra API para comprobar las funcionalidades de los mismos)


</br>

#### 12.1) Prueba de Funcionalidad con `Postman`
* Levantar el Servicio de Mysql.
	* --> Abrir  xampp y click en Mysql
* Ejecutar el Proyecto Spring 
* Visualizar en la salida de consola cu谩l es el Puerto en el c煤al est谩 corriendo el Servidor de Spring Tomcat. (En mi caso es el 8092, el puerto es configurable)
* Descargar la herramienta Postman. (Fijarse los links de descarga en el apartado de Tecnolog铆as Empleadas.) 
* Una vez descargada crear un usuario y ejecutar la aplicaci贸n.
* Una vez que todos los pasos anteriores se est谩n ejecutando sin problemas, vamos a tener que pasarle lo que es la url a Postman y probar cada m茅todo.

</br>


#### 12.2) Test M茅todo  `agregarProducto` mediante  `POST`
* El Primer M茅todo ser谩 el de `agregarProducto`, dentro de Postman en el recuadro de la aplicaci贸n seleccionamos el M茅todo POST y colocamos la URL `http://localhost:8092/v1/producto`
* Vamos a trabajar con Json. Seleccionamos el recuadro de Body, y en el 煤ltimo item buscamos Json
* Escribimos el Registro que vamos a agregar a la db en formato Json
* C贸digo Snippet..

```json
{
    "codigo":"ART-990",
    "nombre":"Monitor 32 pulgadas",
    "precio":33.334

}
```
* Recordar que el id es auto incremental y dinamico
* Click en Send y verificamos la respuesta(true se agrego el registro, false no se agrego)
* Comprobar la tabla producto de la db a trav茅s de phpMyAdmin y verificar el proceso a trav茅s de la terminal de Spring Tool


</br>

#### 12.3) Test M茅todo  `editarProducto` mediante  `PUT`
* El Segundo M茅todo ser谩 el de `editarProducto`, dentro de Postman en el recuadro de la aplicaci贸n seleccionamos el M茅todo PUT y colocamos la URL `http://localhost:8092/v1/producto`
* Vamos a trabajar con Json. Seleccionamos el recuadro de Body, y en el 煤ltimo item buscamos Json
* Escribimos el Registro que vamos a agregar a la db en formato Json
* `ATENTI`, este m茅todo es para editar un producto, por lo que el cuerpo de solicitud que se deba pasar en postman deber谩 incluir el id de ese producto.
* Vamos a cambiar todos los campos menos el id
* C贸digo Snippet..

```json
{
    "id": 1,
    "codigo":"ART-991",
    "nombre":"Monitor 16 pulgadas",
    "precio": 26.000

}
```


* Click en Send y verificamos la respuesta(true se agrego el registro, false no se agrego)
* Comprobar la tabla producto de la db a trav茅s de phpMyAdmin y verificar el proceso a trav茅s de la terminal de Spring Tool



</br>

#### 12.4) Test M茅todo  `eliminarProducto` mediante  `DELETE`
* El Tercer M茅todo ser谩 el de `eliminarProducto`, dentro de Postman en el recuadro de la aplicaci贸n seleccionamos el M茅todo DELETE y colocamos la URL `http://localhost:8092/v1/producto/idDelProductoAeliminar`. Si queremos eliminar el producto con el id 1 la URI completa ser铆a `http://localhost:8092/v1/producto/1`
* La Eliminaci贸n del Producto no posee cuerpo Json.
* Click en Send y verificamos la respuesta(true si se agrego el registro, false no se agrego)
* Comprobar la tabla producto de la db a trav茅s de phpMyAdmin y verificar el proceso a trav茅s de la terminal de Spring Tool.



</br>

#### 12.5) Test M茅todo  `listadoProductos` mediante  `GET`
* El Cuarto M茅todo ser谩 el de `listadoProductos`, dentro de Postman en el recuadro de la aplicaci贸n seleccionamos el M茅todo GET y colocamos la URL `http://localhost:8092/v1/productos`.
* Click en Send y verificamos la respuesta(deber铆amos tener la lista de Productos dentro del body en la respuesta de postman).

* Para obtener la primera p谩gina de productos con 2 registros, vamos a incluir en la URI, luego de productos signo de interrogaci贸n seguidamente el n煤mero de paginaci贸n con page y el tama帽o de esa paginaci贸n,l osea el n煤mero de registros. (?page=0&size=2)
* URI completa `http://localhost:8092/v1/productos?page=0&size=2`.
* Tendriamos 2 productos de la Primera paginaci贸n, podemos pedir que se traiga m谩s productos o cambiar mismo de paginaci贸n, a elecci贸n de uno.

</br>

#### 12.6) Test M茅todo  `getById` mediante  `GET`
* Este M茅todo nos traer谩 el Producto seg煤n su ID de origen
* URI completa `http://localhost:8092/v1/productos/id/1`
* Click en send y la api nos regresa el producto correspondiente


</br>

#### 12.7) Test M茅todo  `getByNombre` mediante  `GET`
* Este M茅todo nos traer谩 el/los Producto/s seg煤n su nombre
* URI completa `http://localhost:8092/v1/productos/nombre/Teclado Gamer RGB Ninkiuop`
* Click en send y la api nos regresa el producto correspondiente


</br>
 
 * El Resto de los M茅todos de B煤squeda funcionan de la misma forma



</br>



## Secci贸n 7) Creaci贸n y Configuraci贸n de SpringSecurity y Json Web Tokens


</br>




 ### Paso 13)  Creaci贸n y Configuraci贸n de la Clase `Usuario`
 #### (Esta Clase ser谩 la Entidad que JPA-HIBERNATE mapee para crear la tabla en la Base de Datos.)

</br>

#### 13.1) Creaci贸n de la Clase `Usuario`
* Esta clase se alojar谩 dentro de `mypackages.entities`
* Creamos la Clase en ese paquete, los pasos para la creaci贸n de la misma ya son conocidos.
* C贸digo Snippet...

```java
package com.api.productos.mypackages.entities;

public class Usuario {
	

}

```



</br>

#### 13.2) Configuraci贸n de la Clase `Usuario`
* Vamos a hacer uso de las anotaciones JPA para persistir y crear los campos en la db, hay que tener en consideraci贸n, que como bien se explico en las primeras sesiones, JPA persisti y reemplaza los valores en la db, osea que si no se creo las tablas nombradas en estas entidades hibernate las crea en la db, por ende hay que tener mayor enfasis en el nombramiento de atributos y clases en las entidades, para esta ocasi贸n no vamos a crear la tabala en la base de datos, sino que directamente vamos a trabajar desde la clase en Java, nuevamente aclaro, ojo con los nombres y convenciones entre Java y SQL.
* Adem谩s dicha clase va a emplementar un Serializable, para convertir los Beans en flujos de Bytes.
* Los 煤ltimos 2 atributos de la clase hacen referencia a la sesi贸n del usuario, si es admin, usuario convencional o lo que fuese, y si el estado de tipo booelan para los dem谩s atributos que tenga dicho usuario, si posee activo o no los atributos que vayamos a comparar.
* C贸digo Completo...

```java
package com.api.productos.mypackages.entities;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;


@Entity
@Table(name="usuarios")
public class Usuario implements Serializable{
	
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Id
	@Column(name="id" , unique= true)
	private int id;

	@Column(name="usuario" , unique= true)
	private String usuario;
	
	
	@Column(name="contrasenia")
	private String contrasenia;

	@Column(name="rol")
	private byte rol;

	@Column(name="estado")
	private boolean estado;
	
	
	
	

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsuario() {
		return usuario;
	}

	public void setUsuario(String usuario) {
		this.usuario = usuario;
	}

	public String getContrasenia() {
		return contrasenia;
	}

	public void setContrasenia(String contrasenia) {
		this.contrasenia = contrasenia;
	}

	public byte getRol() {
		return rol;
	}

	public void setRol(byte rol) {
		this.rol = rol;
	}

	public boolean getEstado() {
		return estado;
	}

	public void setEstado(boolean estado) {
		this.estado = estado;
	}

	@Override
	public String toString() {
		return "Usuario [id=" + id + ", usuario=" + usuario + ", contrasenia=" + contrasenia + ", rol=" + rol
				+ ", estado=" + estado + "]";
	}
	
	
	
	

}


```






</br>


 ### Paso 14) Creaci贸n y Configuraci贸n de la Interfaz `I_UsuarioRepository`
 #### (Esta Interfaz tendr谩 el mismo objetivo que la ya definida, siguiendo el patr贸n de dise帽o DAO, sin definir el cuerpo de las funciones ya que trabajaremos con la API de JpaRepository)

</br>



#### 14.1) Creaci贸n de la Interfaz `I_UsuarioRepository`
* Esta interfaz se alojar谩 dentro de `mypackages.repositories.interfaces`
* Creamos la Interfaz en ese paquete, los pasos para la creaci贸n de la misma ya son conocidos.
* C贸digo Snippet...

```java
package com.api.productos.mypackages.repositories.interfaces;

public interface I_UsuarioRepository {

}


```



</br>

#### 14.2) Configuraci贸n de la Interfaz `I_UsuarioRepository`
* Vamos a hacer uso de las anotaciones de Spring para que trabaje con jpaRepository
* Al igual que la otra interfaz, esta contendr谩 los m茅todos de JPA
* C贸digo Completo...

```java
package com.api.productos.mypackages.repositories.interfaces;

import java.io.Serializable;
import java.util.List;

import javax.persistence.Column;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.api.productos.mypackages.entities.Producto;
import com.api.productos.mypackages.entities.Usuario;

@Repository("I_UsuarioRepository")
public interface I_UsuarioRepository extends JpaRepository<Usuario, Serializable>{

	public abstract Usuario findById(int id);

	public abstract Usuario findByUsuario(String usuario);
	
	public abstract Usuario findByContrasenia(String contrasenia);

	public abstract Usuario findByRol(byte rol);
	
	public abstract Usuario findByEstado(boolean estado);



	
}


```


</br>


 ### Paso 15) Creaci贸n y Configuraci贸n del Servicio `UsuarioService`
 #### (Ya sabemos que en el service desarrollamos la l贸gica de negocio de la aplicaci贸n)

</br>

#### 15.1) Creaci贸n del Servicio `UsuarioService`
* Este servicio se alojar谩 dentro de `mypackages.services`
* Creamos la Clase Service en ese paquete, los pasos para la creaci贸n de la misma ya son conocidos.
* C贸digo Snippet...

```java
package com.api.productos.mypackages.service;

public class UsuarioService {

}


```



</br>

#### 15.2) Configuraci贸n del Servicio `UsuarioService`
* Vamos a hacer uso de las anotaciones de Spring para que trabaje con jpaRepository,  los pasos y anotaciones son los mismos que el otro service, la funcionalidad es la misma, la unica diferencia es que trabajamos con el repositorio y la entidad del Usuario
* Al igual que el otro service se har谩 uso de la inyecci贸n de dependencias
* Vamos a implementar la Interfaz `UserDetailsService`, esta se va a encargar que el usuario acceda directamente al contenido de las bases de datos, esta interfaz describe nu objeto que realizaz un acceso a datos con un unico metodo llmado `loadUserByUsername` que devuelve la info de un usuario.  Esto lo vamos a hacer con el metodo declarado en la interfaz `findByUsuario`.Previamente Crearemos un objeto encoder para trabajar con las contrase帽as cifradas, debemos pasarles este encoder cuando invoquemos al metodo getContrasenia de la Clase Usuario
* El M茅todo findByUsuario nos devuelve un usuario, pero necesitamos los detalles del mismo, por ende vamos a instanciar un objeto de tipo `User`, esta clase del paquete del core de spring tiene   7 argumentos que debemos pasarle,  el usuario, password, la habilitacion, la autorizacion, etc.
* Adem谩s vamos a crear una funci贸n llamada `obtenerPermisos` que nos devuelva una Lista de tipo `GrantedAuthority`, que son los permisos para un usuario en concreto, entonces el argumento de la funcion esparara el rol (que permiso tiene el usuario) y nos devolver谩 los permisos a trav茅s de una simple estructura de dato. En este M茅todo trabajamos con un array con permisos de lectura, usuario o admin, creamos un for que referencia a cada uno de ellos, el permiso de lectura corresponde al Cero, el de Usuario al Uno y Administrador al Dos, entonces cuando en el parametro de la funcion se pase alguno de estos correspondientes n煤meros se har谩 referencia a que permiso/rol se tenga
* C贸digo funci贸n..
```java
public List<GrantedAuthority> obtenerPermisos(byte rol){
		
		String roles[] = {"LECTURA","USUARIO","ADMINISTRADOR"};
		
		List<GrantedAuthority> auths = new ArrayList();
		
		for(int i=0 ; i < rol ; i++) {
			auths.add(new SimpleGrantedAuthority(roles[i]));
		}
		
		return auths;
	}
```
* C贸digo Completo...

```java
 package com.api.productos.mypackages.service;

import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import com.api.productos.mypackages.entities.Usuario;
import com.api.productos.mypackages.repositories.interfaces.I_UsuarioRepository;

@Service("UsuarioService")
public class UsuarioService implements UserDetailsService{


	// ========= INYECCIN DE DEPENDENCIAS ==========
	@Autowired
	@Qualifier("I_UsuarioRepository")
	private I_UsuarioRepository iUsuarioRepository;

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		
		PasswordEncoder encoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();
		 
		Usuario usuario = iUsuarioRepository.findByUsuario(username);
		
		return new User(usuario.getUsuario() , encoder.encode(usuario.getContrasenia()) , usuario.getEstado() 
				, usuario.getEstado() , usuario.getEstado() , usuario.getEstado() 
				, obtenerPermisos(usuario.getRol()));
	}
	
	public List<GrantedAuthority> obtenerPermisos(byte rol){
		
		String roles[] = {"LECTURA","USUARIO","ADMINISTRADOR"};
		
		List<GrantedAuthority> auths = new ArrayList();
		
		for(int i=0 ; i < rol ; i++) {
			auths.add(new SimpleGrantedAuthority(roles[i]));
		}
		
		
		
		return auths;
	}
	
	
	
}

```

</br>


 ### Paso 16)  Creaci贸n y Configuraci贸n de la Clase de Configuraci贸n `UsuarioConfiguration`
 #### (Esta Clase ser谩 el Modelo de Acceso a la DB para obtener el usuario y contrase帽a de la db y asi poder validar el login, atenti que la Clase Usuario es para persistir los datos con JPA y la Clase UsuarioConfiguration es para obtener los datos, utilizaremos Spring Security y Json Web Tokens con esta clase)

</br>

#### 16.1) Creaci贸n de la Clase de Configuracion `UsuarioConfiguration`
* Creamos la clase dentro del paquete `mypackages.configurations` ya creado previamente para la clase anterior 
* C贸digo Snippet...

```java
package com.api.productos.mypackages.configurations;

public class UsuarioConfiguration {

}


```


</br>

#### 16.2) Configuraci贸n de la Clase de Configuracion `UsuarioConfiguration`
* Esta clase debe de enviar un token hacia la clase WebConfiguration, el token lo deber谩 generar otra clase llamada `JwtUtil`, pasar谩 por un filtro a trav茅s de la clase a煤n no creada `JwFilter` entre otras cosas.
* Creamos atributos getters y setters..
* C贸digo Snippet...

```java
package com.api.productos.mypackages.configurations;

public class UsuarioConfiguration {
	
	private String usuario;
	private String contrasenia;
	
	
	public String getUsuario() {
		return usuario;
	}

	
	
	public void setUsuario(String usuario) {
		this.usuario = usuario;
	}

	public String getContrasenia() {
		return contrasenia;
	}

	public void setContrasenia(String contrasenia) {
		this.contrasenia = contrasenia;
	}

	
	

}


```




</br>


 ### Paso 17) Creaci贸n y Configuraci贸n de la Clase de Configuraci贸n `JwtUtilConfiguration` 
 #### (Esta Clase ser谩 la que genere el token del cliente cada vez que se valida el usuario y contrase帽a. Una vez que el cliente necesite usar la aplicaci贸n deber谩 mandar ese token generado para solicitar dicho recurso )

</br>

#### 17.1) Creaci贸n de la Clase de Configuracion `JwtUtilConfiguration` 
* Creamos la clase dentro del paquete `mypackages.configurations` ya creado previamente para la clase anterior 
* C贸digo Snippet...

```java
package com.api.productos.mypackages.configurations;

public class JwtUtilConfiguration {

}


```


</br>

#### 17.2) Configuraci贸n de la Clase de Configuracion `JwtUtilConfiguration` 
* La descripci贸n de cada cosa esta mismo en los comentarios del c贸digo..
* C贸digo Completo..
```java
package com.api.productos.mypackages.configurations;

import java.util.Date;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import static java.util.Collections.emptyList;

public class JwtUtilConfiguration {
	
	
	// M茅todo para crear el JWT y enviarlo al cliente en el header de la respuesta
    static void addAuthentication(HttpServletResponse res, String username) {

        String token = Jwts.builder()
            .setSubject(username)
                
            // Vamos a asignar un tiempo de expiracion de 10 minuto
            // solo con fines demostrativos en el video que hay al final
            .setExpiration(new Date(System.currentTimeMillis() + 600000))
            
            // Hash con el que firmaremos la clave
            .signWith(SignatureAlgorithm.HS512, "UsuarioValidado")
            .compact();

        //agregamos al encabezado el token
        res.addHeader("Authorization", "Token: " + token);
    }

    // M茅todo para validar el token enviado por el cliente
    static Authentication getAuthentication(HttpServletRequest request) {
        
        // Obtenemos el token que viene en el encabezado de la peticion
        String token = request.getHeader("Authorization");
        
        // si hay un token presente, entonces lo validamos
        if (token != null) {
            String user = Jwts.parser()
                    .setSigningKey("UsuarioValidado")
                    .parseClaimsJws(token.replace("Token:", "")) //este metodo es el que valida
                    .getBody()
                    .getSubject();

            // Recordamos que para las dem谩s peticiones que no sean /login
            // no requerimos una autenticacion por username/password 
            // por este motivo podemos devolver un UsernamePasswordAuthenticationToken sin password
            return user != null ?
                    new UsernamePasswordAuthenticationToken(user, null, emptyList()) :
                    null;
        }
        return null;
    }

}

}


```
* Hay Muchas cosas que podriamos hablar hacerca de JWT, pero en este caso la mayor relevancia para las pruebas con Postman es el tiempo de expiraci贸n de los Tokens, por defecto en la documentaci贸n viene configurado a 1 minuto, ac谩 se modifica a 10 para no tener que estar agregando los nuevos en cada peticion, tambi茅n se podr铆a quitar el mismo pero por temas de seguridad se deja.
 
 </br>
 
 
 ### Paso 18) Creaci贸n y Configuraci贸n de la Clase de Configuraci贸n `JwtFilterConfiguration` 
 #### (Esta Clase ser谩 la que se encargue de validar el token proporcionado por el cliente, recordar, el cliente proporciona usuario y contrase帽a y como respuesta se le envia un token con toda la seguridad detr谩s del mismo, ese token el cliente lo usar谩 cada vez que se quiera conectar a la aplicaci贸n, entonces este filtro sirve para validar ese token)

</br>


#### 18.1) Creaci贸n de la Clase de Configuracion `JwtFilterConfiguration` 
* Creamos la clase dentro del paquete `mypackages.configurations`.
* C贸digo Snippet...

```java
package com.api.productos.mypackages.configurations;

public class JwtFilterConfiguration {

}


```


</br>

#### 18.2) Configuraci贸n de la Clase de Configuracion `JwtFilterConfiguration` 
* Vamos a implementar el metodo de la clase `GenericFilterBean` llamado `doFilter`.
* La clase que se hereda es una superclase para cualquier tipo de filtro. La conversi贸n de tipos de par谩metros de configuraci贸n es autom谩tica, y el m茅todo setter correspondiente se invoca con el valor convertido. Tambi茅n es posible que las subclases especifiquen las propiedades requeridas. Los par谩metros sin que coincidan con el configurador de propiedades de bean simplemente se ignorar谩n. 
* El M茅todo `doFilter`  es un metodo filtro de servlet que interceptan dinamicamente solicitudes y respuestas para transformar o utilizar la informacion contenida en las mismas
* Luego llamaremos al jwtUtil trayendo la autenticacion con el request del cliente, seguidamente se aplica un `SecurityContextHolder`, Esta clase proporciona una serie de m茅todos est谩ticos que delegan en una instancia de SecurityContextHolderStrategy. El prop贸sito de la clase es proporcionar una forma conveniente de especificar la estrategia que se debe usar para una JVM determinada. Esta es una configuraci贸n de toda la JVM, ya que todo en esta clase es para facilitar el uso en el c贸digo de llamada .static
* Por ltimo aplicamos el `filterChain` para concluir el proceso de filtrado 
```java

package com.api.productos.mypackages.configurations;

import java.io.IOException;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.GenericFilterBean;

public class JwtFilterConfiguration extends GenericFilterBean{

	
	@Override
    public void doFilter(ServletRequest request,
                         ServletResponse response,
                         FilterChain filterChain)
            throws IOException, ServletException {


        Authentication authentication = JwtUtilConfiguration.getAuthentication((HttpServletRequest)request);

        SecurityContextHolder.getContext().setAuthentication(authentication);

        filterChain.doFilter(request,response);
    }
	
	
}


```


</br>


 ### Paso 19) Creaci贸n y Configuraci贸n de la Clase de Configuraci贸n `LoginFilterConfiguration` 
 #### (Esta Clase ser谩 la que procese los tokens de solicitud de autenticaci贸n creados mediante la implementaci贸n de las otras clases)

</br>

#### 19.1) Creaci贸n de la Clase de Configuracion `LoginFilterConfiguration` 
* Creamos la clase dentro del paquete `mypackages.configurations`.
* C贸digo Snippet...

```java
package com.api.productos.mypackages.configurations;

public class LoginFilterConfiguration {

}


```


</br>

#### 19.2) Configuraci贸n de la Clase de Configuracion `LoginFilterConfiguration` 
* Esta clase heredara las funcionalidades de la clase `AbstractAuthenticationProcessingFilter`,que a su vez esta procesa los tokens de solicitud ed autenticaci贸n..
* Debemos implementar el m茅todo de dicha clase, porque el constructor ser谩 completamente modificado, en los parametros de el constructor se le pasara la URL desde el Service que crearemos m谩s adelante  `WebSecurity`, el segundo parametro sera de tipo `AuthenticationManager`, que es una interfaz para la autenticaci贸n, esta devuelve una instancia con el indicador establecido en true.
* Dentro del constructor, invocando al padre, creamos una instancia de `AntPathRequestMatcher` pasandole la url, este objeto compara la url con un patron predefinido omitido y coincidira o no con los metodos http.
* Luego invocamos al metodo `setAuthenticationManager` pasandole el `authManager`, el metodo obtiene una instancia de autenticacion para usarla en solicitudes posteriores
* C贸digo del constructor `LoginFilterConfiguration` ...

```java
 public LoginFilterConfiguration(String url, AuthenticationManager authManager) {
	        super(new AntPathRequestMatcher(url));
	        setAuthenticationManager(authManager);
	    }

```

* El M茅todo `attemptAuthentication` procesa el envio de un formulario de autenticaci贸n. Los formularios de inicio de sesi贸n deben presentar dos par谩metros a este filtro: un nombre y una contrase帽a. Los parametros de dicho metodo ser谩n `HttpServletRequest` y `HttpServletResponse`, el primero para manejar y obtener la petici贸n del cliente y el segundo para procesarla.
* Dentro de dicho m茅todo declaramos una variable de tipo InputStream para obtener la petici贸n en formato JSON. Luego creamos otra variable de tipo User para realizar el mapeo a nuestra clase UsuarioConfiguration para almacenar los datos, usuario y contrase帽a
* Por 煤ltimo dicho m茅todo va a devolver una Colecci贸n de elementos, el usuario y contrase帽a autenticado, en esta parte se compara el token
* C贸digo del m茅todo `attemptAuthentication` ...

```java
@Override
	    public Authentication attemptAuthentication(
	            HttpServletRequest req, HttpServletResponse res)
	            throws AuthenticationException, IOException, ServletException {

	        // obtenemos el body de la peticion que asumimos viene en formato JSON
	        InputStream body = req.getInputStream();

	      //Leemos los valores del Json (usuario y contrase帽a)
	        UsuarioConfiguration user = new ObjectMapper().readValue(body, UsuarioConfiguration.class);

	        // Finalmente autenticamos
	        // Spring comparar谩 el user/password recibidos
	        // contra el que definimos en la clase SecurityConfig
	        return getAuthenticationManager().authenticate(
	                new UsernamePasswordAuthenticationToken(
	                        user.getUsuario(),
	                        user.getContrasenia(),
	                        Collections.emptyList()
	                )
	        );
	}
```
* Por ltimo crearemos el m茅todo que valide todo el proceso de autenticaci贸n llamdo `successfulAuthetication` se aplicaran los m茅todos https, el FilterChain y el Authentication en sus parametros. El m茅todo en s铆 llama a la clase que genera el token `JwtUtilConfiguration` y agrega la autenticacion 
* C贸digo del m茅todo `successfulAuthentication`..
```java
@Override
	    protected void successfulAuthentication(
	            HttpServletRequest req,
	            HttpServletResponse res, FilterChain chain,
	            Authentication auth) throws IOException, ServletException {

	        // Si la autenticacion fue exitosa, agregamos el token a la respuesta
	        JwtUtilConfiguration.addAuthentication(res, auth.getName());
	    }

```

* C贸digo Completo de la Clase `LoginFilterConfiguration`
```java
package com.api.productos.mypackages.configurations;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

import com.fasterxml.jackson.databind.ObjectMapper;

public class LoginFilterConfiguration extends AbstractAuthenticationProcessingFilter{

	  public LoginFilterConfiguration(String url, AuthenticationManager authManager) {
	        super(new AntPathRequestMatcher(url));
	        setAuthenticationManager(authManager);
	    }

	  @Override
	    public Authentication attemptAuthentication(
	            HttpServletRequest req, HttpServletResponse res)
	            throws AuthenticationException, IOException, ServletException {

	        // obtenemos el body de la peticion que asumimos viene en formato JSON
	        InputStream body = req.getInputStream();

	       //Leemos los valores del Json (usuario y contrase帽a)
	        UsuarioConfiguration user = new ObjectMapper().readValue(body, UsuarioConfiguration.class);

	        // Finalmente autenticamos
	        // Spring comparar谩 el user/password recibidos
	        // contra el que definimos en la clase SecurityConfig
	        return getAuthenticationManager().authenticate(
	                new UsernamePasswordAuthenticationToken(
	                        user.getUsuario(),
	                        user.getContrasenia(),
	                        Collections.emptyList()
	                )
	        );
	    }
	  
	  @Override
	    protected void successfulAuthentication(
	            HttpServletRequest req,
	            HttpServletResponse res, FilterChain chain,
	            Authentication auth) throws IOException, ServletException {

	        // Si la autenticacion fue exitosa, agregamos el token a la respuesta
	        JwtUtilConfiguration.addAuthentication(res, auth.getName());
	    }

}

```





</br>

 ### Paso 20) Creaci贸n y Configuraci贸n de la Clase de Configuraci贸n `WebSecurity`
 #### (Esta clase va a proporcionar seguridad basada en la web, como por ejemplo que el usuaio se autentique antes de acceder a cualquier URL dentro de nuestra aplicacion, manejo de roles(permisos de usuarios), autenticacion HTTP, paginas de inicio y cierre de sesion, etc)

</br>

#### 20.1) Creaci贸n de la Clase Configuration `WebSecurity`
* Vamos a crear la clase en el mismo paquetes que todas las clases de configuracion, `mypackages.configurations` 
* C贸digo Snippet...

```java
package com.api.productos.mypackages.configurations;

public class WebSecurity {

}


```



</br>


#### 20.2) Configuraci贸n de la Clase Configuration `WebSecurity`
* Para una clase de configuration necesitaremos la anotacion `@Configuration` 
* Para activar la seguridad en la clase empleamos la anotacion `@EnableWebSecurity`
* Esta clase va a heredar de `WebSecurityConfigurerAdapter`, de esta forma podemos personalizar WebSecurity y HttpSecurity, podemos replicar el comportamiento obteniendo multiples elementos http heredando en los diferentes beans(clases) 
* Vamos a utilizar inyecci贸n de dependencias para traer las funcionalidades de nuestro `UsuarioService`
* C贸digo Inyecci贸n..
```java
	// ========= INYECCIN DE DEPENDENCIAS ==========
		@Autowired
		@Qualifier("UsuarioService")
		private UsuarioService usuarioService;

	

```
* Implementamos los 2 m茅todos m谩s usados de la clase `configure(AuthenticationManagerBuilder auth)` y `configure(HttpSecurity http)`
* Vamos a reestructurar el cuerpo de cada uno de los metodos..
* En el `configure(AuthenticationManagerBuilder auth)` implementamos el UsuarioService a traves del m茅todo `userDetailsService`
* Con esta funci贸n spring comprueba y realiza la verificaci贸n de autenticaci贸n de tal usuario
* C贸digo funci贸n..
```java
	
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		
//M茅todo para comprobar el user y password en la db		auth.userDetailsService(usuarioService);
		
			/*
		// Podemos Cargar el Usuario y Contrase帽a en Memoria sin usar la db
        auth.inMemoryAuthentication()
                .withUser("admin")
                .password("admin")
                .roles("ADMIN");
		*/
		
	}


```
* El segundo m茅todo se deber谩 pasar en su parametro un elemento de tipo `HttpSecurity`,  este permite configurar la seguridad basada en la web para solicitudes http. La configuracion requerira que cualquier URL que se solicite requiere un Usuario con el rol "ROLE_USER". Tambi茅n se define un esquema de autenticaci贸n en memoria con un usuario que tiene un nombre y contrase帽a. Seguidamente esta funcion permitar谩 el ingreso a cualquier usuario a trav茅s de la url `/login`, estas peticiones a traves dee esta peticion pasar谩n por los filtros desarrollados en cada clase, entonces, cualquier cliente puede ingresar a la url pero no a la aplicacion, si el cliente x ingresa usuario y contrase帽a adecuado se genera el famoso token que seran las credenciales de ese cliente, caso de que ese cliente x no ingrese el usuario y contrase帽o correcto no se generar谩 ese token y solamente tendr谩 acceso al login y no a la aplicacion.
* C贸digo funci贸n..
```java
	

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.csrf().disable().authorizeRequests()
        .antMatchers("/login").permitAll() //permitimos el acceso a /login a cualquiera
        .anyRequest().authenticated() //cualquier otra peticion requiere autenticacion
        .and()
        // Las peticiones /login pasaran previamente por este filtro
        .addFilterBefore(new LoginFilterConfiguration("/login", authenticationManager()),
                UsernamePasswordAuthenticationFilter.class)
            
        // Las dem谩s peticiones pasar谩n por este filtro para validar el token
        .addFilterBefore(new JwtFilterConfiguration(),
                UsernamePasswordAuthenticationFilter.class);
	}
```

* C贸digo Completo de la clase `WebSecurityConfiguration`..

```java
package com.api.productos.mypackages.configurations;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.api.productos.mypackages.repositories.interfaces.I_ProductoRepository;
import com.api.productos.mypackages.service.UsuarioService;

@Configuration
@EnableWebSecurity
public class WebSecurity extends WebSecurityConfigurerAdapter {

	
	// ========= INYECCIN DE DEPENDENCIAS ==========
		@Autowired
		@Qualifier("UsuarioService")
		private UsuarioService usuarioService;

	
	
	
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		
		//M茅todo para comprobar el user y password en la db
		auth.userDetailsService(usuarioService);
		
		/*
		// Podemos Cargar el Usuario y Contrase帽a en Memoria sin usar la db
        auth.inMemoryAuthentication()
                .withUser("admin")
                .password("admin")
                .roles("ADMIN");
		*/
		
	}

	
	
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.csrf().disable().authorizeRequests()
        .antMatchers("/login").permitAll() //permitimos el acceso a /login a cualquiera
        .anyRequest().authenticated() //cualquier otra peticion requiere autenticacion
        .and()
        // Las peticiones /login pasaran previamente por este filtro
        .addFilterBefore(new LoginFilterConfiguration("/login", authenticationManager()),
                UsernamePasswordAuthenticationFilter.class)
            
        // Las dem谩s peticiones pasar谩n por este filtro para validar el token
        .addFilterBefore(new JwtFilterConfiguration(),
                UsernamePasswordAuthenticationFilter.class);
	}

	
	
	
}


```

* Para Spring Security me gu铆e por los siguientes tutoriales : https://github.com/windoctor7/codigo-tutoriales-blog/tree/master/spring-auth-jwt o https://windoctor7.github.io/spring-jwt.html u otro tutorial https://windoctor7.github.io/spring-jwt.html
* Adem谩s videotutorial :https://www.youtube.com/watch?v=Gw2d7t1vqLg&list=PLcIHm18h1i4m1xuhwrL-LjVjf5wuYFRCV&index=13
* Los Nombres y M茅todos fueron Modificados a gusto, no est谩 completamente identico




 </br>
 
 
 ### Paso 21) Test de `Spring Security` y `JWT`  
 #### (Llegar hasta este punto no fue f谩cil, intent茅 describir lo mejor posible que es lo que hace cada m茅todo y funcionalidad implementada, desde ya que de forma superficial por qu茅 no es un tema f谩cil de digerir, para testear la seguridad vamos a usar nuevamente Postman)
 
 </br>
 
 #### 21.1) Modificaci贸n de los usos de los M茅todos HTTP en el `ProductoController`
 #### (Para trabajar con los m茅todos http tenemos que tener primerasmente los roles y usuarios levantados en la db, este paso lo haremos luego)
 
 * Nos dirijimos hacia el ProductoController y vamos a agregar la Anotattion `@PreAuthorize("hasRole('ADMINISTRADOR')")` para los m茅todos PostMapping, PutMapping y DeleteMapping, el GetMapping no es relevante para los dem谩s usuarios.
 * C贸digo Final de la Clase `ProductoController`..
 ```java
 package com.api.productos.mypackages.controllers;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.domain.Pageable;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.api.productos.mypackages.entities.Producto;
import com.api.productos.mypackages.models.ProductoModel;
import com.api.productos.mypackages.service.ProductoService;


@RestController
@RequestMapping("/v1")
public class ProductoController {
	
	//==========INYECCION DEL SERVICE==========
	@Autowired
	@Qualifier("ProductoService")
	ProductoService productoService;

	
	
	//==========MTODOS HTTP====================
	
	//METODO POST
	@PreAuthorize("hasRole('ADMINISTRADOR')")
	@PostMapping("/producto")
	public boolean agregarProducto(@RequestBody @Validated Producto producto) {
		return productoService.agregarProducto(producto);
	}
	
	//MTODO PUT
	@PreAuthorize("hasRole('ADMINISTRADOR')")
	@PutMapping("/producto")
	public boolean editarProducto(@RequestBody @Validated Producto producto) {
		return productoService.editarProducto(producto);
		
	}
	
	//MTODO DELETE
	@PreAuthorize("hasRole('ADMINISTRADOR')")
	@DeleteMapping("/producto/{id}")
	public boolean eliminarProducto(@PathVariable("id") int id) {
		return productoService.eliminarProducto(id);
			
		}
	
	//MTODO GET
	@GetMapping("/productos")
	public List<ProductoModel> listadoProductos(Pageable pageable){
		return productoService.listadoProductos(pageable);
	}
	

	

}
 
 ```
 
  </br>
 
 
 #### 21.2) Agregar los Registros de Seguridad para los Usuarios 
 #### (En esta aplicaci贸n tenemos 3 tipos de usuarios seg煤n los declarados en UsuarioService, que corresponde al campo rol de la Entidad Usuario, adem谩s tenemos el campo estado, que nos permitir谩 activar o desactivar dichos permisos en la db, vamos a agregar un registro y testear dicha Seguridad)
 
 * Si todo se ha ejecutado correctamente en los pasos anteriores tendr铆amos la tabla usuarios vacia creada en la db, desde PHPMYADMIN seleccionamos dicha tabla e insertamos desde el editor de linea o pesta帽a SQL el registro..
  
```sql
use db_api_productos;

insert into usuarios(id, contrasenia, estado, rol, usuario) values(1,'admin', 1 , 2 ,'admin');

```
* El campo estado es de tipo boolean y el campo rol de tipo byte, este validar谩 para 0, 1 o 2 (LECTURA, USUARIO, ADMINISTRADOR)

</br>

 #### 21.3) Verificaci贸n de `Tokens` y `Usuarios`
* Luego en Postman usaremos la ruta `http://localhost:8092/login` de tipo POST con pasandole en el Bodyel usuario y contrase帽a que tendriamos levantado en la db en formato Json 
 ```json
 {
"usuario":"admin" , "contrasenia":"admin"
    }
```
* Click en Send y Obtenemos un `Status 200 OK`, la petici贸n HTTP fue exitosa, si nos fijamos en la Pesta帽a de `Headers` veremos una key llamada `Authorization` con el Valor `Token: eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImV4cCI6MTY0MzE0ODg1NX0.syW7nAEnKjrWgOU2SWunB4XCyGTWqnHTZoNeZxr3urQ_sjvgRBqBVuFaAUEOs2tNqAoRweoF9dnFL8NhH31Uxw `, este token cambia por cada petici贸n, podemos configurar todo lo que queramos, pero tenemos funcionando SPRING SECURITY Y JWT.

</br>

 #### 21.4) Verificaci贸n de `Spring Security`
 * Veamos si pasando otro usuario y contrase帽a Spring nos devuelve un token 
 * Usamos la misma ruta `http://localhost:8092/login` de tipo POST  pasandole un usuario y contrase帽a incorrecto y no insertado en la db en formato Json 
 ```json
 {
"usuario":"juan" , "contrasenia":"perez"
    }
```
* Obtenemos un `401 Unauthorized`, no tenemos autorizaci贸n para usar esta aplicaci贸n, de la misma forma se puede implementar otro usuario y guardar el estado en 0, false para que si bien este registrado en la base de datos no tenga permisos por equis motivo, esto me parece super interesante, tiene una potencialidad muy grande.


 </br>
 
 
 ### Paso 22) Verificaci贸n de la `API Productos` con JWT 
 #### (Vamos a testear nuevamente los m茅todos de la api con JWT)
 * Vimos que podemos o no tener acceso a nuestra Api, teniendo el acceso pertinente vamos a consultar los productos que tenemos en nuestra Base de Datos
 * Repetimos el Proceso de Obtenci贸n de nuestro token para hacer uso de nuestra credencial
*  Ruta `http://localhost:8092/login` en el Body mandamos un Json..
 ```json
 {
"usuario":"admin" , "contrasenia":"admin"
    }
```
* Obtenemos Nuestro Token `Token: eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImV4cCI6MTY0MzE0OTY4M30.RJ_cWIsyR8sgLKwe7HE80L_P2AyO5GXeldUYJJIEDE2tKT6EVC6-kdBn-DPoSUhHL57XVtcCEnbXXMaUbdGWSQ`
* Este token (SIN LA PALABRA TOKEN:) lo vamos a pegar en el `VALUE` de la key `Authorization` dentro de la pesta帽a `Headers`, si no est谩 configurada esta key-value agregar
* Luego cambiamos la ruta de la petici贸n a `http://localhost:8092/v1/productos`, tipo de M茅todo GET y Click en Send
* Obtenemos un `Status 200 OK` y dentro de la Pesta帽a Body del Response obtenemos todos los productos de nuestra API..
 ```json
[
    {
        "id": 3,
        "codigo": "JLU-332",
        "nombre": "Teclado Gamer RGB Ninkiuop",
        "precio": "6.500"
    },
    {
        "id": 2,
        "codigo": "ART-990",
        "nombre": "Monitor 32 pulgadas",
        "precio": "33.334"
    },
    {
        "id": 4,
        "codigo": "KTE-111",
        "nombre": "Mouse Inalambrico",
        "precio": "3.200"
    },
    {
        "id": 5,
        "codigo": "KTE-111",
        "nombre": "Mouse Inalambrico",
        "precio": "3.200"
    },
    {
        "id": 6,
        "codigo": "KTE-112",
        "nombre": "Mouse Inalambrico 4.0",
        "precio": "3.700"
    },
    {
        "id": 7,
        "codigo": "KTE-114",
        "nombre": "Mouse Inalambrico 5.0",
        "precio": "4.200"
    }
]
```

</br>

* Podemos pedir el producto con el ID 3, URI : (`http://localhost:8092/v1/productos/id/3`)
* Obtenemos...
```json
{
    "id": 3,
    "codigo": "JLU-332",
    "nombre": "Teclado Gamer RGB Ninkiuop",
    "precio": "6.500"
}

```
</br>

* Podemos pedir el producto, o los productos segun su c贸digo, URI : (`http://localhost:8092/v1/productos/codigo/KKLU-847`)
* Obtenemos...
```json
[
    {
        "id": 8,
        "codigo": "KKLU-847",
        "nombre": "Parlante Blueetoth 4.0",
        "precio": 4.5
    },
    {
        "id": 9,
        "codigo": "KKLU-847",
        "nombre": "Parlante Blueetoth 4.0 IMPORTADO DE BRASIL",
        "precio": 4.5
    }
]

```

</br>


* Traemos el Producto o un Listado seg煤n su Nombre , URI : (`http://localhost:8092/v1/productos/nombre/Mouse Inalambrico`)
* Obtenemos...
```json
[
    {
        "id": 4,
        "codigo": "KTE-111",
        "nombre": "Mouse Inalambrico",
        "precio": "3.200"
    },
    {
        "id": 5,
        "codigo": "KTE-111",
        "nombre": "Mouse Inalambrico",
        "precio": "3.200"
    }
]

```
* LA API ES COMPLETAMENTE FUNCIONAL




</br>



## Secci贸n 8) Anotaciones


</br>


 ### Anotaciones Usadas para JPA
 
| **Tipo de Anotaci贸n** | **Finalidad** |               
| ------------- | ------------- |
| @Table(name="nombreTabla") | Definici贸n de Nombre de Tabla SQL. |
| @Column(name="nombreCampo") | Definici贸n de Nombre de Campo SQL. |
| @Entity | Definici贸n de Entidad, para que la misma pueda ser mapeada a una Tabla SQL. |
| @Id | Definici贸n de Campo tipo identificador entero SQL. |



</br>


 ### Anotaciones Usadas para Spring Boot y Spring Security
 
| **Componentes e Inyecci贸n de Dependencia** | **Finalidad** |               
| ------------- | ------------- |
| @Component("nombreComponente") |  Establecemos la clase Java como un bean o componente para que el mecanismo de exploraci贸n de componentes de Spring pueda agregarla al contexto de la aplicaci贸n |
| @Repository("nombreRepositorio") | Estereotipo para la Capa de Persistencia. |
| @Service("NombreServicio") | Registrar el componente y permitir que se inyecten otras clases a 茅l|
| @Autowired | Inyecci贸n de Dependencias. Busca un objeto Bean que implementen determinada interfaz y lo referencia para no crear una nueva instancia del objeto. |
| @Qualifier("NombreBean") | Nombramos el Bean que queremos inyectar. Se evita la ambigueda cuando Spring encuentra multiples beans del mismo tipo. |

</br>

| **Solicitudes HTTP** | **Finalidad** |
| ------------- | ------------- |
| @RestController | Con esta anotaci贸n le indicamos a Spring que ser谩 un componente de tipo controlador, adem谩s permitimos el manejo de solicitudes HTTP usando la API REST. | 
| @RequestMapping("rutaVersionadoApi") | Se va a encargar de relacionar un m茅todo con una petici贸n http |
| @RequestBody | Nos permite Recuperar el Cuerpo de la Solicitud HTTP |
| @Validated | Ejecuta Validaciones para los M茅todos de una Clase |
| @PutMapping("ruta") | Propiedad de Petici贸n HTTP PUT |
| @PostMapping("ruta") | Propiedad de Petici贸n HTTP POST|
| @DeleteMapping("ruta") | Propiedad de petici贸n HTTP DELETE |
| @PathVariable("parametro") | Permite Manejar las variables declaradas dentro del mapping(put,delete,etc) para la asignaci贸n de la URI de la solicitud HTTP y establecerlas como parametros del m茅todo |


</br>

| **Spring Security** | **Finalidad** |
| ------------- | ------------- |
| @Configuration | Activamos las solicitudes de Servicios para estos Beans |
| @EnableWebSecurity | Activamos SpringSecurity en nuestra aplicaci贸n |


</br>

</br>


</br>

## Secci贸n 9) Uso y Manejo de Git.

</br>

### Uso y Manejo de Git
### Descarga de Git
* Nos dirigimos a https://git-scm.com/downloads y descargamos el versionador
* Como toda aplicacion siguiente.... siguiente....
* IMPORTANTE:NO TENER ABIERTO EL IDE DURANTE LA INSTALACION, SINO NO RECONOCE EL PATH

### Abrir una Consola de Git desde el IDE
* --> Seleccionamos el Proyecto
* --> Click Der 
* --> Show in Local Terminal
* --> Seleccionas Git Console 


### Subir el proyecto al repositorio desde la consola de git dentro del IDE

#### 1)Creamos un nuevo repositorio en GitHub.

#### 2)Inicializamos nuestro repositorio local .git desde la terminal.
* git init

#### 3)Agregamos lo desarrollado a nuestro repo local desde la terminal.
* git add *

#### 4)Agregamos lo que tenemos en nuestro repo local al 谩rea de Trabajo desde la terminal.
* git commit -m "agrega un comentario entre comillas"

#### 5)Le indicamos a git donde se va a almacenar nuestro proyecto(fijate en tu repositorio de github cual es el enlace de tu proyecto(esta en code)).
* git remote add origin https://github.com/andresWeitzel/Api_Rest_Spring_Productos

#### 6)Subimos nuestro proyecto.
* git push -u origin master


</br>


### Actualizaci贸n del proyecto al repositorio desde la consola de GIT en el IDE

#### 1)Visualizamos las modificaciones realizadas en local
* git status

#### 2)Agregamos lo modificado al area de trabajo
* git add *

#### 3)Confirmamos las modificaciones realizadas
* git commit -m "tu commit entre comillas"

#### 4)Sincronizamos y traemos todos los cambios del repositorio remoto a la rama en la que estemos trabajando actualmente.
##### (SOLO SI SE REALIZARON CAMBIOS DESDE OTRA LADO, ej: en github u/o/y un equipo de trabajo)
* git pullhttps://github.com/andresWeitzel/Api_Rest_Spring_Productos

#### 5)Enviamos todos los cambios locales al repo en github
* git push https://github.com/andresWeitzel/Api_Rest_Spring_Productos

#### 6) En casos extremos pisamos todo el repositorio
* git push -f --set-upstream origin master


</br>


